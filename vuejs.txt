
# vuejs

Vue.jsはUIなどを組み立てるView層にフォーカスしたJavaScriptライブラリです。
Vue.jsの特徴として、
リアクティブなデータバインディング、
再利用性の高いコンポーネントによるUIの構築、
仮想DOMによる高速なレンダリング、
シンプルなAPIなどが挙げられます。
シンプルでわかりやすく作られているため、
少しの学習でもすぐアプリケーション作成に役立てることができます。

また、Vue.jsをサポートするライブラリやツール、
整備されたドキュメント類、Vue.jsユーザーのコミュニティやフォーラムなど、
開発を進める過程で助けとなるものが数多く用意されているのも魅力の一つです。

データバインディングを試してみよう

input要素にmessageがバインディングされ、
テキストボックスの内容を変えるとmessageの値が更新され、
同時にmessageを参照している{{message}}の内容が更新されます。

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <div id="app"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.2/vue.js"></script>
    <script>
      new Vue({
        el: '#app',
        template: `
          <div>
            <p><input v-model="message"></p>
            <p>{{message}}</p>
          </div>
        `,
        data: {
          message: 'Hello Vue.js!!'
        }
      })
    </script>
  </body>
</html>

JavaScriptのコードとしては10数行ですが、
これだけでDOMとデータの同期ができます。
このようにVue.jsではHTMLテンプレートを使った宣言的なデータバインディングが簡単に行えます。

高速なレンダリング

Vue.jsは2系から、
仮想DOMを採用しています。仮想DOMの採用によって、
ほかのフレームワークと比較しても、
より最適化された高速なレンダリングが可能になりました。
仮想DOMについては、使うときに特に意識せずとも、その恩恵を受けることができます。

公式ブログでは、
第三者の描画速度のベンチマーク結果をまとめたグラフが掲載されています。
Vanilla JavaScript（ライブラリを用いない素のJavaScript）の処理速度を1として、
その何倍の時間がかかるかを表したもので、
数値が低いほど処理速度が速いということになります。

あらゆる規模で使えるフレームワーク

公式サイトを見ると「The Progressive JavaScript Framework」という見慣れない用語があると思います。
これは作者のEvan You氏が提唱する
"Progressive Framework（プログレッシブ・フレームワーク）"という概念です。

アプリケーションは、多くの場合、作って終わりということはなく、
その後も開発が続けられます。要求に合わせて新しい機能を追加したり、
ときには仕様を変更したりと、
アプリケーションを成長させる必要があります。
アプリケーションの成長段階において、
採用したフレームワーク（ライブラリ）が要求に合わなくなるというのはよくある話です。
こういったアプリの成長に対応できるフレームワーク、
それがProgressive Frameworkという概念です。

Progressive Frameworkが意味しているのは、
Vue.jsがどのような規模、段階のアプリケーションにも対応できるということです。
Vue.js単体を見ると、小規模のアプリケーションに適しているように思いますが、
Vue.jsをサポートするツールやライブラリといったエコシステムの存在によって、
アプリケーションの要求に柔軟に対応することができます。

開発をサポートするツール

前述したように、
Vue.jsを使った開発ではアプリケーションの要求に合わせて、
Vue.jsをサポートするライブラリやツールを採用していくことなります。
vuejsのリポジトリには、多くのライブラリやツールがあります。

vue-cli

vue-cliはVue.jsのプロジェクトを始める際に、
プロジェクトの雛形を生成（scaffolding：本来の意味は「足場」）してくれるツールです。

vue-cliを使うと、
webpackやBrowserifyを使ったバンドル環境の設定、
ファイルに変更があったときに差分だけを再読込してくれるローカルサーバーの設定を自動で行ってくれます。

またこれには、
後述するvueifyやvue-loaderによる
単一コンポーネントでのアプリケーション開発を行える環境のセットアップも行ってくれます。

vueifyとvue-loader

Vue.jsは
UIをコンポーネント（部品）ごとに定義して、
それを組み立てることでアプリケーションを構築します。

このコンポーネントの定義をよりやりやすくするのが、
vueifyとvue-loaderです。

vueifyとvue-loaderは基本的に同じ目的を持ったものですが、
vueifyがBrowserifyを使ったもの、
vue-loaderがwebpackを使ったものという点が異なります。

コンポーネントは
.vueという独自の拡張子のファイルで生成し、
この中にコンポーネントのHTML、CSS、JavaScriptを定義します。

次のソースコードは.vueファイルの例です。

template要素にHTMLテンプレートを、
style要素にCSSを、
script要素にJavaScriptを記述します。

<template>
  <div class="my-component">
    <button @click="onClick">{{message}}</button>
  </div>
</template>

<style lang="scss" scoped>
  .my-component {
    color: tomato;
    button {
      border: 1px solid #000;
    }
  }
</style>

<script>
  export default {
    data() {
      return {
        message: 'Hello!!'
      }
    },
    methods: {
      onClick() {
        console.log(this.message)
      }
    }
  }
</script>

vueifyとvue-loaderは
単にコンポーネントごとにファイルを分けるだけでなく、
SassやBabelといった、
CSSプリプロセッサやJavaScriptトランスパイラへの対応も簡単に行えるようになっています。

styleのlang属性の値としてscssやstylusといった指定をすることで、
面倒な設定なしにCSSプリプロセッサを利用できます。
また、
デフォルトでBabelによるトランスパイルが行われるようになっているので、
ES2015などの構文を存分に利用することができます。

Vuex

中規模、大規模なアプリケーションになってくると、
状態（データ）をどこに持たせるのかが問題になったり、
コンポーネント同士でデータのやり取りをしていたために、
コンポーネントの再利用性が低くなったりします。
このようなアプリケーションのデータに関する問題を解決するために利用するのが
Vuex（ビュエックス）です。

Vuexは、
Fluxに代表されるような状態管理パターンをVue.jsで行うためのライブラリです。

単一のState（状態）を
ActionsとMutationsによって変更し、
その変更をきっかけにVue ComponentsがUIの更新を行います。

Vuexを使うことで、
複雑になりがちなデータの管理を
シンプルにわかりやすく行えます。

そのほかの連携ライブラリ

Vue.jsは
ルーティングや通信の機能を持っていません。
Single Page Applicationを作るときなどには、
次に紹介するライブラリを使うことができます。

vue-router

vue-routerは
Vue.js公式のルーティングライブラリです。
公式のライブラリだけあって、
Vue.jsのコンポーネントを利用することに最適化されています。

vue-validator

vue-validatorは
Vue.js公式のフォームバリデーションライブラリです。
フォームに入力された値が期待している値かどうかチェックすることができます。

組み合わせるライブラリの選択

Vue.jsの公式ライブラリを紹介しましたが
「公式が提供しているものを使わなければならない」ということはありません。
公式ライブラリを使うことの利点は、
Vue.js本体の更新に合わせてライブラリも更新されることです。
サードパーティ製のライブラリは更新が突然止まって、
Vue.js本体の更新に追いつけなくなったり、
Vue.jsと組み合わせて使うのに適さなくなる可能性があります。

ただし、これはVue.jsのコア領域に関わるようなライブラリにだけ当てはまります。

たとえば、
外部リソースを取得するライブラリは
Vue.jsのコア領域には関わりがありません。
ですのでaxiosや、
それこそjQuery（の$.ajax）などの、
サードパーティ製ライブラリを自由に選択することができます。

Vue.jsの特徴と、
Vue.jsをサポートするツールやライブラリについて紹介しました。
次回はVue.jsのAPIの中から、特に使用頻度が高いものについて解説します。

Vue.jsのインストール

まずはVue.jsを使えるようにしましょう。
Vue.jsはGitHubリポジトリのreleaseページからダウンロードする方法、
CDNを使う方法、npmでインストール方法があります。

npmからインストールする場合には、コマンドラインから次のコマンドを実行します。

$ npm install vue

またほかの方法としてvue-cliを使ってテンプレートとともに環境を構築する方法もあります。

vue-cliの利用

vue-cliを次のように
-gオプションを付けてインストールします。

$ npm install -g vue-cli

インストール完了後、vueコマンドが使えるようになります。
新しくプロジェクトを作成する際には次のようにvue initを実行することで、テンプレートをダウンロードすることができます。

$ vue init <template-name> <project-name>

<tempalte-name>には
公式が提供しているテンプレートの名前と、
GitHubのリポジトリが指定できます。
筆者は公式が提供している次の2つのテンプレートのうちのどちらかを利用することをお勧めします。

    webpack
    browserify

これらのテンプレートを使うと、
.vueファイルによるコンポーネントの作成、ローカルサーバーによる部分的なモジュールの更新など、
開発を進める上で便利な環境がすぐに利用できるようになります。

準備ができたところで、
次節以降ではVue.jsの基本中の基本をおさえていくことにしましょう。

VueインスタンスとDOM要素を紐付ける

Vue.jsは作成したVueインスタンスを
DOM要素と紐付けることで機能します。
インスタンスを紐付けるにはelオプション、
もしくは$mount()を使います。

説明のために、
ここではHTML上に<div id="app"></div>という要素が存在する、
という前提で進めます。

<div id="app"></div>

elオプションを使って
idがappである要素にVueインスタンスを紐付けるには、
次のようにelにCSSのセレクタ#appを指定します。

const vm = new Vue({
  el: '#app',
  template: `<div>
    app
  </div>`
})

これは$mount()を使って次のように記述できます。

const vm = new Vue({
  template: `<div>
    app
  </div>`
})

vm.$mount('#app')

デモでは紐付けただけの状態なので、
ブラウザ上にappと表示されるだけです。

elオプションと$mount()にはCSSセレクタ以外にも、
doument.querySelector()などで取得できるDOM要素も指定できます。

State（状態）を持たせる

Vueインスタンスやコンポーネントに
Stateを持たせるには、次のようにdataオプションを使います。
ここではmessageというプロパティを定義しています。

const vm = new Vue({
  el: '#app',
  template: `<div>
    {{message}}
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!'
    }
  }
})

Stateはtemplateから{{}}（Mustache記法）で参照することができます。
templateから参照している値は、Stateが更新された際に自動的に表示も更新されます。

dataオプションの定義には、
オブジェクトをそのまま指定する方法と、
関数によってオブジェクトをreturnする方法の2つがあります。

メソッドを定義する

Vueインスタンスにメソッドを追加する場合には、
次のようにmethodsオプションに定義します。
ここではcountに1を足していくincrement()を定義しています。

const vm = new Vue({
  el: '#app',
  template: `<div>
    {{message}}:{{count}}
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!',
      count: 0
    }
  },
  methods: {
    increment() {
      this.count += 1
    }
  }
})

methodsや後述するcomputedなどからStateを参照する際には、
プロパティ名にthisを付けて参照します。
またdataで定義した値はthis.$dataという変数に格納されていますが、
これは省略することができます。

templateからメソッドを呼び出す

定義したincrement()を
templateから呼び出すには、v-onディレクティブを使います。

v-onディレクティブは
v-on:イベント名="メソッド名"という形式で記述します。
ボタンがクリックされたときにincrement()を呼び出すには、
v-on:click="increment"となります。
なお、以降、コードが重複する部分は省略して差分部分だけを示します。

...
  template: `<div>
    <button v-on:click="increment">increment</button>
    <div>{{message}}:{{count}}</div>
  </div>`,
...

ボタンをクリックするとincrement()が呼ばれ、countに加算された結果が表示されます。

v-onディレクティブは省略記法が用意されています。次のように@clickといった具合に、v-onを@で置き替えることができます。

...
  template: `<div>
    <button @click="increment">increment</button>
    <div>{{message}}:{{count}}</div>
  </div>`,
...

v-が付いたディレクティブが多く存在しているので、
テンプレートの見通しをよくするために
@による省略記法を使うことをお勧めします。

# 算出プロパティを利用する

プロパティ同士を計算した結果を表示したり、Stateによって条件判定を行うなど、なんらかの処理を加えた値を表示することがあります。こういった場合には、computedオプションを使います。

たとえば、computedオプションに、messageとcountを繋げた文字列を返すmessageAndCountプロパティを定義します。templateからこのプロパティを参照することで、テンプレート上で文字列を結合するような処理を書く必要がなくなります。

...
  template: `<div>
    <button @click="increment">increment</button>
    <div>{{messageAndCount}}</div>
  </div>`,

...

  computed: {
    messageAndCount() {
      return `${this.message}:${this.count}`
    }
  }
})

computedオプションで定義されたプロパティは、

プロパティ内部で使用されているプロパティ（ここではmessageとcount）が更新された場合に、
自動的に計算をし直して、表示する値も更新されます。

テンプレート上にはできるだけロジックを書かないようにすることが、
テンプレートの見通しをよくするためにも望ましいことです。

ここまでて、Vue.jsを用いたWebアプリケーション作成の基礎的な部分がおわかりいただけたかと思います。

次節からはディレクティブについて解説します。

# DOM操作を行うディレクティブ

Vue.jsには
ディレクティブ（directive）と呼ばれる、
DOM操作を行うための組み込みの機能が用意されています。
ディレクティブにはv-という接頭辞が付けられています。
Vue.jsには10種類を超えるディレクティブがありますが、こ
こではよく使うディレクティブについて解説します。

# イベントのハンドリングを行うv-on

v-onディレクティブは
DOM上で起こるイベントをハンドリングするためのディレクティブです。

前述したclick以外にも
submitやkeyupなど、DOM上で起こるイベントをハンドリングできます。
また、
次回以降解説する$emit()によるイベントのトリガーも
v-onを使ってハンドリングすることができます。

# フォーム要素で便利なv-model

v-modelディレクティブは
フォーム要素のvalueとVueインスタンスのStateをバインディングするディレクティブです。
次のようにinput要素にv-modelディレクティブでプロパティ名を指定すると、
テキストボックスの変更と合わせて指定したプロパティの値も更新されます。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div>{{messageAndCount}}</div>
  </div>`,
...

# 条件によってDOMの表示／非表示を切り替えるv-ifとv-show

特定の条件を満たすとき／満たさないときに、
要素の表示／非表示を切り替えたいときがあると思います。
そういったときには、v-ifディレクティブか
v-showディレクティブを使います。

v-ifディレクティブとv-showディレクティブは、指定された値（条件式）がtrueのときに要素を表示し、
値がfalseのときに要素を非表示にします。

例として、v-ifディレクティブを使って
countプロパティが奇数のときにだけmessageAndCountが表示されるようにしてみます。

次のように表示と非表示を切り替えたい要素にv-ifディレクティブで条件式を指定します。

ここでは2で割った余りが1になるとき（つまり奇数）のときに表示されるようにしています。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-if="count % 2 !== 0">{{messageAndCount}}</div>
  </div>`,
...

increment()を実行すると表示／非表示が交互に切り替わります。

# v-ifとv-showの違い

v-showディレクティブも
要素を非表示にするものですが、v-ifディレクティブとはいくつか異なる点があります。
v-ifディレクティブはfalseと評価される値が指定されたときにDOM上から要素を取り除くことで非表示にしますが、
v-showディレクティブはCSSのdisplayにnoneを指定して非表示にします。

また、v-ifディレクティブでは
falseと評価される値が指定されたときにだけ表示される要素をv-elseディレクティブで指定することができます。

次のように、v-ifディレクティブを指定した要素に隣接するように、
v-elseディレクティブを指定した要素を記述します。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-if="count % 2 !== 0">{{messageAndCount}}</div>
    <div v-else>この要素はcountが偶数のときに表示されます</div>
  </div>`,
...

ボタンをクリックすると、
v-ifディレクティブを指定した要素とv-elseディレクティブを指定した要素が交互に表示されます。

# 動的に属性値を割り当てるv-bind

classやstyleなど、
Stateや条件によって
動的に値を適用したいときがあります。
そうったときにはv-bindディレクティブを使います。

次の例はcomputedのプロパティとして
styleObjectというインラインスタイルのためのプロパティを定義しています。
colorはthis.countが奇数のときに'red'、偶数のときに'blue'になります。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-bind:style="styleObject">{{messageAndCount}}</div>
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!',
      count: 0
    }
  },
  methods: {
    increment() {
      this.count += 1
    }
  },
  computed: {
    messageAndCount() {
      return `${this.message}:${this.count}`
    },
    styleObject() {
      return {
        color: this.count % 2 !== 0 ? 'red' : 'blue',
        fontSize: '16px'
      }
    }
  }
...

この例ではcomputedオプションを使用していますが、
templateにそのまま記述することもできますし、dataのプロパティを参照することもできます。
v-bindはstyleやclassに限らず、
値を要素に動的にバインディングする場合、全般において使えます。

また、v-bindディレクティブには省略記法が用意されており、
v-bindを省略して:hoge="fuga"といった記述で指定することもできます。

# 繰り返し表示を行うv-for

配列やオブジェクトなど、
値が単一でないプロパティの表示には
v-forディレクティブを使います。
次の例では文字列を格納した配列colorsと、
オブジェクトを格納したusersを定義し、
v-forディレクティブによって表示しています。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-bind:style="styleObject">{{messageAndCount}}</div>
    <div>colors:
      <span v-for="color in colors" :style="{color}">{{color}} </span>
    </div>
    <div>users:
      <div v-for="user in users">
        {{user.id}}:{{user.name}}
      </div>
    </div>
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!',
      count: 0,
      colors: ['red', 'blue', 'green'],
      users: [
        {id: 1, name: 'ユーザ１'},
        {id: 2, name: 'ユーザ２'}
      ]
    }
  },
...

v-forはcolor in colorsといった形式で、
右側にVueインスタンスが持っているプロパティ名（ここではcolors）を指定し、
左側にはv-forの繰り返し内で参照できるように
エイリアス（ここではcolor）を指定します。

v-forディレクティブで
オブジェクトの値を繰り返し処理する場合、user.idのように参照することもできますが、
次のようにvalueとkeyをエイリアスとして指定することができます。

...
    <div>users:
      <div v-for="user in users">
        <span v-for="(value, key) in user">
          {{key}}:{{value}},
        </span>
      </div>
    </div>
  </div>`,
...

ここではv-for="user in users"としている繰り返し処理の中で、
さらに
v-forディレクティブを使い、v-for="(value, key) in user"として、
userプロパティが持っているプロパティのkeyとvalueを列挙しています。

このように、
v-forディレクティブを使うことで
繰り返し処理も簡潔に記述することができます。

次回から、アプリケーションを作りながらVue.jsの実践的な使い方について解説していきます。

まず今回作成していくサンプルアプリケーションの完成形の動作をデモで確認してみましょう。
デモを実行してどのような動作をするのかを把握してください。

内容、日付、タグを入力し、保存ボタンをクリックすると、ページ内にその内容が保存されます。

アプリケーションの構成

このアプリケーションは次の3つのコンポーネントで構成されています。

    メモを追加するEditorView

    メモを表示するListItem

    ListItemをリスト表示するListView

これら3つのコンポーネントを組み合わせて、メモアプリケーションとして動作するようにします。

そのほかの設計方針

このシリーズでは、
設計方針としてFlux的な状態管理の手法をベースに考えていきます。
コンポーネントは
親コンポーネントなどから与えられたデータを表示するのが主な役割となるので、
機能としての必然性がない限り、
コンポーネント独自の状態を持たせないようにします。
また、状態の変更が各コンポーネントに散らばらないように、
データの追加・削除・更新などの処理はコンポーネントでは行わず、
ルートのインスタンスで行うようにします。

今回のアプリケーションでは、
ListViewと
ListItemは独自の状態を持たず、
親コンポーネントから渡されたデータを表示するだけです。
EditorViewは
ユーザーの入力を必要とするので入力項目の状態を持たせますが、
メモを追加する処理はルートのインスタンスが行うようにします。

まずは
Vue.jsが動作するようにファイルを準備します。

ページのベースとなるHTMLとして、
次のHTMLをindex.htmlとして保存します。

index.html

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>vue-memo</title>
  <link rel="stylesheet" href="./styles.css">
</head>
<body>
  <div id="app"></div>
  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script src="components/ListItem.js"></script>
  <script src="components/ListView.js"></script>
  <script src="components/EditorView.js"></script>
  <script src="app.js"></script>
</body>
</html>

index.htmlでは
Vue.js本体と3つのコンポーネント、
後述するapp.jsを読み込むように記述しておきます。

合わせて、
デモ用のスタイルとして次のCSSをstyles.cssとして保存し、読み込むように指定しておきます。

次に、メインの処理を記述していくJavaScriptファイルとして、次のコードをapp.jsとして保存します。
app.js

const vm = new Vue({
  el: '#app',
  data() {
    return {}
  },
  template: `
    <div></div>
  `
})

app.jsにはid属性値がappである要素にVueインスタンスを紐付けるようにしておきます。

最後に、コンポーネントの処理を記述する3つのJavaScriptファイルを作成しておきます。これらのファイルは、この時点では空のままで大丈夫です。

    components/ListItem.js
    components/ListView.js
    components/EditorView.js

これらのファイルを作ると次のようなファイル構成になります。

.
├── app.js
├── components
│   ├── EditorView.js
│   ├── ListItem.js
│   └── ListView.js
├── index.html
└── styles.css

# Step1. ListItemコンポーネントでメモを表示する

まずは
メモの内容を表示するListItemコンポーネントの作成です。
ListItem.jsを次のように変更します。
ここでは表示のテスト用の値として、memoというプロパティに
メモの内容を持たせておきます。

ListItem.js

Vue.component('list-item', {
  data() {
    return {
      memo: {
        id: 1,
        text: 'テスト',
        date: '16-10-28',
        tags: ['タグ1', 'タグ2']
      }
    }
  },
  template: `
    <div class="list-item">
      <div>
        <span>id</span>：
        <span>{{memo.id}}</span>
      </div>
      <div>
        <span>text</span>：
        <span>{{memo.text}}</span>
      </div>
      <div>
        <span>date</span>：
        <span>{{memo.date}}</span>
      </div>
      <div>
        <span>tags</span>：
        <span>
          <span v-for="tag in memo.tags">{{tag}}</span>
        </span>
      </div>
    </div>
  `
})

ここではVue.component()を使い、
list-itemという名前でコンポーネントを登録しています。

このコンポーネントは、ほかのコンポーネントから<list-item></list-item>とすることで、

HTMLのカスタムタグのように使用できます。

memo.tagsは配列なので、
v-forディレクティブを使って繰り返し処理で値を表示します。

次にapp.jsでListItemコンポーネントを使うように、
template部分を変更します。
コンポーネントはVue.component()に指定した名前（list-item）をタグとして使います。

app.js

const vm = new Vue({
  el: '#app',
  data () {
    return {}
  },
  template: `
    <div>
      <list-item></list-item>
    </div>
  `
})

ここまでの状態です。実行すると、メモの内容が表示されます。

# Step2. EditorViewからメモを追加する

次にメモを追加するEditorViewコンポーネントを作成します。
EditorViewにはtext、date、tagsを入力するinput要素を定義し、
保存ボタンをクリックしたらsave()を実行するように変更します。

EditorView.jsを次のように変更します。

EditorView.js

Vue.component('editor-view', {
  template: `
    <div class="editor-view">
      <div>
        <label>内容：</label>
        <input v-model="input.text" placeholder="メモのタイトル">
      </div>
      <div>
        <label>日付：</label>
        <input type="date" v-model="input.date">
      </div>
      <div>
        <label>タグ：</label>
        <input v-model="input.tags" placeholder="空白区切りで指定">
      </div>
      <div>
        <button @click="save">保存</button>
      </div>
    </div>
  `,
  data() {
    return {
      input: {
        text: '',
        date: '',
        tags: ''
      }
    }
  },
  computed: {
    tagsArr() {
      // input.tags の文字列を空白で区切って配列に変換する
      return this.input.tags.trim() !== '' ? this.input.tags.trim().split(/\s+/) : []
    }
  },
  methods: {
    save() {
      // this.input のクローンを生成する
      const data = Object.assign({}, this.input, {tags: this.tagsArr})
      // 'add'イベントを自身にトリガーする
      this.$emit('add', data)
    }
  }
})

3つのinput要素はv-modelディレクティブで、
それぞれinputプロパティにバインディングしています。
save()はinputプロパティをクローンして処理を加えたあと、
$emit()で'add'イベントをトリガーします。
app.jsはこの'add'イベントをハンドリングして値を受取るように変更します。

app.jsで'add'イベントをハンドリングしてデータを受け取るように変更します。

コンポーネントからのイベントは、
v-onディレクティブでハンドリングすることができます。
ここではeditor-viewで
'add'イベントが発生したときにadd()を呼ぶように<editor-view @add="add">としています。

const vm = new Vue({
  el: '#app',
  data() {
    return {
      memo: {
        id: 1,
        text: '',
        date: '',
        tags: ''
      }
    }
  },
  template: `
    <div>
      <editor-view @add="add"></editor-view>
      <list-item></list-item>
    </div>
  `,
  methods: {
    add(newMemo) {
      Object.assign(this.memo, newMemo)
    }
  }
})

これでEditorViewから
メモのデータを受け取ることができるようになりましたが、
受け取ったデータをListItemに渡していないので表示できません。
受け取ったデータをv-bindをディレクティブを使ってListItemに渡すように、
templateを変更します。

app.js

...
template: `
  <div>
    <editor-view @add="add"></editor-view>
    <list-item :memo="memo"></list-item>
  </div>
  `
...

これでListItemコンポーネントmemoプロパティの値を渡すようにできましたが、
ListItemコンポーネントはmemoを受け取れるようになっていません。

コンポーネントは
propsオプションを使うことで値を受け取ることができます。
ここではpropsオプションを使い、memoという名前でObjectを受け取るという指定をします。
また、ListItemコンポーネントはpropsで受け取ったmemoを表示することを役割とするため、
dataは削除しておきます。

ListItem.js

Vue.component('list-item', {
  props: {
    memo: Object
  },
  template: `
    （変更なしのため省略）
  `
})

項目を埋めて保存ボタンをクリックすると、
propsで受け取ったデータが表示できていることが確認できます。

# Step.3 ListViewでメモをリスト表示する

次に複数のメモをリスト表示できるように、
ListViewコンポーネントを作成します。
ListViewコンポーネントはmemosというメモの配列をpropsで受取り、
ListItemで表示するようにします。
また、memosが空だった場合にはv-ifディレクティブを使って、
メモの代わりに表示できるメモがありません。
というメッセージを表示するようにします。

ListView.js

Vue.component('list-view', {
  template: `
    <div class="list-view">
      <div v-if="memos && memos.length !== 0">
        <list-item
          v-for="memo in memos"
          :memo="memo">
        </list-item>
      </div>
      <div v-else>
        表示できるメモがありません。
      </div>
    </div>
  `,
  props: {
    memos: Array
  }
})

ListViewコンポーネントにmemosを渡すようにapp.jsを変更します。
また、EditorViewから'add'イベントで受け取ったデータをmemosに追加するように変更します。

app.js

...
  data() {
    return {
      memos: []
    }
  },
  template: `
    <div>
      <editor-view @add="add"></editor-view>
      <list-view :memos="memos"></list-view>
    </div>
  `,
  methods: {
    add(newMemo) {
      newMemo.id = this.nextId
      this.memos.push(newMemo)
    },
  },
  computed: {
    nextId() {
      // this.memos の中で一番大きい id + 1 を返す
      return this.memos.reduce((id, memo) => {
          return id < memo.id ? memo.id : id
        }, 0) + 1
    }
  }
})

メモの追加時に、
追加するメモに対してidを設定しています。
computedのnextIdは
memosの中で一番大きいidに1を加えた数値を返します。

実行すると、項目を埋めて保存ボタンをクリックするごとにメモが追加されていくのが確認できます。

# Step.4 メモを削除できるようにする

もっとアプリケーションらしくするため、
追加したメモを削除できるようにしてみましょう。

ListItemコンポーネントに削除ボタンを追加し、
クリックされたときにremove()を呼ぶように変更します。

ListItem.js

...
template: `
  <div class="list-item">
    <div>
      <span>id</span>：
      <span>{{memo.id}}</span>
    </div>
    <div>
      <span>text</span>：
      <span>{{memo.text}}</span>
    </div>
    <div>
      <span>date</span>：
      <span>{{memo.date}}</span>
    </div>
    <div>
      <span>tags</span>：
      <span>
        <span v-for="tag in memo.tags">{{tag}}</span>
      </span>
    </div>
    <div>
      <button @click="remove(memo.id)">削除</button>
    </div>
  </div>
`,
methods: {
  remove(id) {
    // this.$parent(ListViewコンポーネント)に
    // 'remove' イベントをトリガーする
    this.$parent.$emit('remove', id)
  }
}
...

remove()ではListItemの親にあたるインスタンス（ListViewコンポーネント）に対して
'remove'イベントをトリガーするようにします。
こうすることで、app.jsでは次のように'remove'イベントをハンドリングすることができるようになります。

app.js

...
template: `
  <div>
    <editor-view @add="add"></editor-view>
    <list-view :memos="memos" @remove="remove"></list-view>
  </div>
`,
methods: {
  add(newMemo) {
    newMemo.id = this.nextId
    this.memos.push(newMemo)
  },
  remove(id) {
    // 該当する id を持つ要素の index を取得する
    const index = this.memos.findIndex((memo) => {
      return memo.id === id
    })
    // this.memos から index にある要素を削除する
    this.memos.splice(index, 1)
  }
},
...

メモを追加し、メモに表示されている削除ボタンをクリックすると、メモが削除されるのを確認できます。

今回は小さなアプリケーションの作成を通して、
コンポーネントの作成とデータの受け渡しや、
イベントハンドリングについて解説しました。
ここまでの内容を習得できれば、
Vue.jsを使って単純なアプリケーションが開発できるはずです。

vue-cliやvue-routerを使った、
本格的なSPAの作成を解説していきます。

# サンプルアプリケーションの概要

まず、これから本シリーズで
数回に渡って作成していくサンプルアプリケーションの完成形の動作を、
デモで確認してみましょう。
どういった実装になっているかはシリーズを通して段階的に解説していきますので、
まずはどのような動作をするのかを把握してください。

ページ構成

アプリケーションは大きくわけて3つのページがあります。
それぞれには次のようなURLと機能を割り当てています。
一覧ページはサブのページとして編集ページを持っています。

ページ名 	ルーティング 	機能

最新 	/ 	最新n件のメモの表示
一覧 	/items 	すべてのメモの一覧表示、メモの絞り込み表示
編集 	/items/:id 	メモの編集
追加 	/add 	新規メモの追加

次回以降、vue-routerを使ってこれらのページのルーティングを追加していきます。

コンポーネント構成

前回作成したアプリケーションと同様に、
アプリケーションは複数のコンポーネントで構成されています。
たとえば、一覧ページは次の図のようになっています。

これらのコンポーネントは、
前回作ったアプリケーションのコンポーネントを再利用しながら作ります。

コンポーネントには、
それぞれ特定の役割を持たせることになります。
ここで使われているコンポーネントは、次のような役割を持っています。

番号 	コンポーネント名 	役割

1 	ListView 	メモをリスト表示する
2 	ListItem 	メモの内容を表示する
3 	EditorView 	メモの追加・編集
4 	NavLink 	ページのナビゲーション

ListViewコンポーネントの中では、ListItemコンポーネントを使ってメモの内容を表示しています。
EditorViewは新規のメモの作成を行う機能を持っていますが、特定の条件を満たしたときにはメモを編集する機能を有効にします。
NavLinkは各ページへのリンクを提供します。

作成工程

これから数回に渡って、
このアプリケーションを作成していきます。
このアプリケーションは、前回作成したアプリケーションをベースにして、
次のような工程を経て完成させます。
メモアプリケーションに必要な機能（ソート、検索、絞り込み）なども適宜追加していきます。

    vue-loaderを使ったコンポーネントの
      .vueファイルへの置き換え
    vue-routerを使ったルーティングの追加

    vue-routerを使ったネストしたルーティングの追加

    アプリケーションの状態管理の変更

    Vuexを使った状態管理

今回の記事では、
最初の工程、vue-loaderを使ったコンポーネントの.vueファイルへの置き換えを解説します。

前回作成したアプリケーションでは、
Vue.component()を使って各コンポーネントを.jsファイルとして記述しました。
以降では、vue-loaderを使って各コンポーネントを.vueファイルで記述します。

# vue-devtoolsのインストール

環境構築に入る前に、
Vue.jsのアプリケーションをデバッグするのに役立つvue-devtoolsをインストールしておきましょう。

vue-devtools
はChrome専用の拡張機能で、
次のリンクからブラウザにインストールすることができます。

    Vue.js devtools - Chrome ウェブストア

インストールするとDevToolsに
Vueパネルが追加され、
アプリケーションやコンポーネントの状態が確認できるようになります。

# vue-cliで環境構築

それでは最初に、vue-cliを使って、
開発用のローカルサーバーやビルドの環境などを構築します。
vue-cliはVue.jsでの開発に必要なこまごまとしたツールを
一括で準備できる便利なツールです。

コマンドラインから
次のコマンドを実行して、vue-cliをグローバルにインストールします。

$ npm install -g vue-cli

インストール完了後、
次のコマンドを実行してvue-cliが正しくインストールされているのを確認します。
正しくインストールされていれば、次のようにバージョン番号が表示されます。

$ vue -V
2.5.1

テンプレートの利用

vue-cliは公式が提供しているテンプレートか、
ユーザーが作成したテンプレートが利用できます。
今回は公式が提供しているwebpackのテンプレートを利用します。
このテンプレートには、
次のような機能が使えるコマンドが用意されています。

    開発用ローカルサーバー：
        ファイルの監視と差分更新

    リリース用のビルド：
        minifyやバンドル

    .vueファイルによるコンポーネント作成

本シリーズでは解説しませんが、
ESLintによる構文チェックや、ユニットテストとE2Eテストなどのテスト環境の構築も行えます。

プロジェクトの作成

早速ですが、
次のコマンドを実行してwebpackのテンプレートを使ったプロジェクトを、
vue-memoという名前で作成します。

$ vue init webpack vue-memo

コマンドを実行すると、
package.jsonに指定するプロジェクトの名前や、
各ツールの使用可否をY/nで答えるように質問されます。
今回"Vue build"まではすべてエンターキーで進めて、
それぞれの質問には次のように回答します。

    ? Vue build: Runtime + Compiler (standalone)：そのままリターン
    ? Use ESLint to lint your code?: No：nを入力
    ? Setup unit tests with Karma + Mocha?: No：nを入力
    ? Setup e2e tests with Nightwatch?: No：nを入力

vue-cli · Generated "vue-memo".というメッセージが表示されたらプロジェクトの生成は完了です。

これだけでvue-loaderを使ったコンポーネントの開発、
ローカルサーバーによる差分更新、リリース用のビルドコマンドなどが行える環境が整えられました。

vue-memoのディレクトリに移動したあと、
npm installを実行して依存パッケージをインストールします。

ローカルサーバーを起動してみる

必要なパッケージのインストールが完了したので、
ローカルサーバーを起動してみましょう。プロジェクトのディレクトリで次のコマンドを実行してローカルサーバーを起動します。

$ npm run dev

正しく起動すると、
ブラウザでlocalhost:8080が開かれて、次のようなページが表示されます。

コンポーネントを編集してみる

このローカルサーバーはファイルに更新があったとき、
自動でブラウザの更新を行ってくれます。
それだけであればよくあるオートリロード機能なのですが、
このローカルサーバーは、
状況によって変更があった差分だけを賢く更新してくれます。
この機能（Hot Module Replacement）によって、よりスムーズに開発を進めることができます。

試しにローカルサーバーを起動した状態で
src/components/Hello.vueの<script>のmsgの文字列部分を、
次のように変更してみましょう。


Hello.vue

export default {
  name: 'hello',
  data () {
    return {
      msg: 'Welcome to CodeGrid !!'
    }
  }
}

ファイルを変更して保存すると、
Welcome to Your Vue.js Appとなっていた箇所が更新されるのを確認できます。
このとき、ローカルサーバーはブラウザをリロードすることなく、
Hello.vueというコンポーネントだけを置きかえるように更新します。

ブラウザの開発者ツールでネットワークパネルを開いた状態にしておくと、
次のような非同期通信が行われているのが確認できます。

アプリケーションの規模が大きくなると、
JavaScriptのバンドルに時間がかかるようになって無駄に時間のロスが発生しがちです。
差分更新を行うにはいろいろと設定が必要なことが多いですが、
公式のテンプレートを利用すれば一切の手間なく、効率的な開発環境が整えられます。

# .vueファイルとは

これから前回作成したアプリケーションを、
コンポーネントのコードをまとめて記述できる.vueファイルに置き換えていきますが、
置き換える前にまず、.vueファイルについて知っておきましょう。

.vueファイルを構成する3つの要素

.vueファイルは次の3つの要素で構成されています。

    <template>: コンポーネントのHTMLを記述する
    <style>: コンポーネントのCSSを記述する
    <script>: コンポーネントのJavaScriptを記述する

次のコードは.vueファイルの例です。

<template>
  <div class="my-component">
    <button @click="onClick">{{message}}</button>
  </div>
</template>

<style lang="scss" scoped>
  .my-component {
    color: tomato;
    button {
      border: 1px solid #000;
    }
  }
</style>

<script>
  export default {
    data() {
      return {
        message: 'Hello!!'
      }
    },
    methods: {
      onClick() {
        console.log(this.message)
      }
    }
  }
</script>

Vue.component()でコンポーネントを作る際には、
コンポーネントのtemplateプロパティにHTMLを文字列として記述していましたが、
.vueファイルでは分離して記述することができます。
コンポーネントのスタイルも
.vueファイルでは同一のファイル内に記述することができ、
コンポーネントのスタイルの管理が比較的やりやすくなります。
.vueファイルの<script>に記述したJavaScriptは、
vue-loaderがBabelによるトランスパイルを行うので、ES2015の構文を使用してJavaScriptを記述できます。

また、<style>では
Scoped CSSのエミュレートや、CSS ModulesによるCSSのカプセル化を行うことができます。
Sassのようなプリプロセッサも、少しの手間で利用できます。

# コンポーネントを.vueファイルにする

それでは実際に
.vueファイルへと置き換えていきましょう。前回作成したメモアプリケーションのコンポーネントは、次のようになっていました。

    前回作成したメモアプリケーションのコンポーネント

準備として、
src/componentsに次の3つのファイルを作成しておきます。

    ListItem.vue
    ListView.vue
    EditorView.vue

    ListItem.vue

    はじめにListItem.jsをListItem.vueにします。

        ListItem.js

ListItem.vueは次のようになります。
  置き換えの手順は単純で、
  コンポーネントのtemplateプロパティの値を<template>として記述し、
  それ以外のプロパティを<script>のexport default {}の中に記述します。
ListItem.vue

    <template>
      <div class="list-item">
        <div>
          <span>id</span>：
          <span>{{memo.id}}</span>
        </div>
        <div>
          <span>text</span>：
          <span>{{memo.text}}</span>
        </div>
        <div>
          <span>date</span>：
          <span>{{memo.date}}</span>
        </div>
        <div>
          <span>tags</span>：
            <span>
              <span v-for="tag in memo.tags">{{tag}}</span>
            </span>
        </div>
        <div>
          <button @click="remove(memo.id)">
            削除
          </button>
        </div>
      </div>
    </template>

    <script>
      export default{
        props: {
          memo: Object
        },
        methods: {
          remove(id) {
            this.$emit('remove', id)
          }
        }
      }
    </script>

    ListView.vue

同じようにListView.jsをListView.vueにします。

        ListView.js

ListView.vueは次のようになります。
ListViewではListItemコンポーネントを利用するので、
ES2015のimport構文を使ってListItem.vueをインポートして定義しておきます。
そしてcomponentsプロパティに指定します。

    ListView.vue

    <template>
      <div class="list-view">
        <div v-if="hasMemo">
          <list-item
            v-for="memo in memos"
            :memo="memo"
            @remove="remove">
          </list-item>
        </div>

        <div v-else>
          表示できるメモがありません。
        </div>
      </div>
    </template>

    <script>
      import ListItem from './ListItem'
      export default{
        props: {
          memos: Array
        },
        computed: {
          hasMemo() {
            return this.memos && this.memos.length !== 0
          }
        },
        methods: {
          remove(id) {
            this.$emit('remove', id)
          }
        },
        components: {
          'list-item': ListItem
        }
      }
    </script>

EditorView.vue

EditorView.jsをEditorView.vueに置き換えます。

        EditorView.js

EditorView.vueは次のようになります。書き換え方法は、これまでの.vueファイルと同様です。

EditorView.vue

    <template>
      <div class="editor-view">
        <div>
          <label>内容：</label>
          <input v-model="input.text" placeholder="メモのタイトル">
        </div>
        <div>
          <label>日付：</label>
          <input type="date" v-model="input.date">
        </div>
        <div>
          <label>タグ：</label>
          <input v-model="input.tags" placeholder="空白区切りで指定">
        </div>
        <div>
          <button @click="save">保存</button>
        </div>
      </div>
    </template>

    <script>
      export default{
        data() {
          return {
            input: {
              text: '',
              date: '',
              tags: ''
            }
          }
        },
        computed: {
          tagsArr() {
            // input.tags の文字列を空白で区切って配列に変換する
            return this.input.tags.trim() !== '' ? this.input.tags.trim().split(/\s+/) : []
          }
        },
        methods: {
          save() {
            // this.input のクローンを生成する
            const data = Object.assign({}, this.input, {tags: this.tagsArr})
            // 'add'イベントを自身にトリガーする
            this.$emit('add', data)
          }
        }
      }
    </script>

    App.vue

最後にapp.jsをApp.vueに移して、アプリケーションが動作するようにします。

        app.js

App.vueは次のようになります。
AppではListViewとEditorViewの2つのコンポーネントを利用するので、
インポートして、componentsに指定します。

App.vue

    <template>
      <div id="app">
        <editor-view @add="add"></editor-view>
        <list-view :memos="memos" @remove="remove"></list-view>
      </div>
    </template>

    <script>
      import EditorView from './components/EditorView'
      import ListView from './components/ListView'

      export default {
        name: 'app',
        data() {
          return {
            memos: [
              {
                id: 1,
                text: 'テスト',
                date: '16-10-28',
                tags: ['タグ1', 'タグ2']
              },
              {
                id: 2,
                text: 'テスト2',
                date: '16-11-28',
                tags: ['タグ2', 'タグ3']
              }
            ]
          }
        },
        computed: {
          nextId() {
            return this.memos.reduce((id, memo) => {
                return id < memo.id ? memo.id : id
              }, 0) + 1
          }
        },
        methods: {
          add(newMemo) {
            newMemo.id = this.nextId
            this.memos.push(newMemo)
          },
          remove(id) {
            const index = this.memos.findIndex((memo) => {
              return memo.id === id
            })
            this.memos.splice(index, 1)
          }
        },
        components: {
          'editor-view': EditorView,
          'list-view': ListView
        }
      }
    </script>

# アプリケーションの動作を確認する

これで前回作成したアプリケーションを
.vueファイルに置き換えることができました。
npm run devコマンドを実行し、
ローカルサーバーで確認してみましょう。
スタイルはあたっていないですが、アプリケーションは前回と同様に動作するのが確認できます。

# スタイルを読み込む

次にアプリケーションにスタイルをあててみましょう。
前回使ったstyles.cssを適用します。

静的なファイルはstaticディレクトリに格納します。
staticディレクトリにstyles.cssを格納すれば、
index.htmlから次のように参照できます。

index.htmlからスタイルを参照

<head>
  <meta charset="utf-8">
  <title>vue-memo</title>
  <link rel="stylesheet" href="/static/styles.css">
</head>

これでもいいですが、
せっかくなのでコンポーネントから参照してみましょう。
App.vueに次のように<style>を追加して参照します。

App.vueからスタイルを参照

<style>
  @import '../static/styles.css';
</style>

これでstyles.cssのスタイルが適用されて、次のような表示になります。

ここまでの状態のソースコードは、次のリポジトリに保存されていますので、
参考にしてください。

今回はvue-cliでテンプレートを利用してプロジェクトを作成し、
.vueファイルでコンポーネントを置き換えるところまでを解説しました。
vue-cliを使えば、すばやくVue.jsを使った開発の環境を整えることができるので、
積極的に利用してみてください。

次回はvue-routerを使った、ページのルーティングについて解説します。

前回はvue-cliを使ってプロジェクトを作成し、
シンプルなメモアプリケーションのコンポーネントを.jsファイルから
.vueファイルに置き換えました。
今回はvue-routerでルーティングを追加していきます。

# ページごとのファイルの作成

vue-routerでは、
ルーティングとコンポーネントをマッピングすることで、
ページに表示するコンテンツを決定します。
たとえば/にアクセスしたときには
Root.vueを表示するといった設定を記述します。

まずはルーティングにマッピングするためのコンポーネントを作成します。

ここで作成するコンポーネントに
各ページのメインコンテンツを制御する役割を持たせます。
今回は次の3つのルーティングに対して、
3つのコンポーネントを作成します。

マッピングするコンポーネントは
通常のコンポーネントと区別するためにsrc/pageディレクトリに作成します。

    /：src/page/Root.vue
    /add：src/page/Add.vue
    /items：src/page/Items.vue

この段階ではこれらのファイルの中身は空の状態で大丈夫です。

# vue-routerのインストール

次のコマンドを実行してvue-routerをインストールします。

$ npm install --save vue-router

インストールしたvue-routerはmain.jsから使いますが、
まずはルーティングの設定ファイルを先に作成します。

# ルーティング設定ファイルの作成

ルーティングの設定を記述していくファイルとして、
src/routes.jsを作成します。

ルーティングは次のように、
routesに各ルーティングの設定を
配列で記述していきます。

pathにはURLを、
componentにはマッピングするコンポーネントを指定します。
ルートにはnameで名前を付けることが可能で、名前を付けておくとページからページへのリンクが簡単になります。

routes.js

import Root from './page/Root'
import Add from './page/Add'
import Items from './page/Items'

export default {
  routes: [
    {
      path: '/', component: Root, name: 'root'
    },
    {
      path: '/add', component: Add, name: 'add'
    },
    {
      path: '/items', component: Items, name: 'items'
    }
  ]
}

動作モードを指定する

URLや履歴の操作に関して、
vue-routerには次の3つの動作モードが用意されています。

    hash
    history
    abstract

デフォルトのモードはhashで、
これは/#/items/5のように#（ハッシュ）を使ったURL Hashによるルーティングを行います。
historyモードはHTML5のHistory APIを使ったもので、
これは#のない/items/5のようなきれいなURLとなり、
完全な履歴を提供します。
abstractモードはhashにもhistoryにも対応していない環境用のモードで、
URLは一切変わらず、履歴も作られません。

どのモードを使うかはフロントエンドだけでなく、
サーバーサイドの環境が関わってくるので、サーバーサイドに合わせて適切なモードを指定しましょう。

本シリーズではhistoryモードを指定して、
アプリケーションの作成を進めていきます。指定は、次のようにrouters.jsにmodeで行います。


routes.js

...
export default {
  // modeを追記
  mode: 'history',
  routes: [
    ...
  ]
}

# ルーターインスタンスの作成と指定

src/routes.jsを元にルーティングを行うよう、
src/main.jsを次のように変更します。

Vue.use()はVue.jsでプラグインを使用するためのメソッドで、
ここではvue-routerを指定しています。
new VueRouter()でルーターインスタンスを作成し、
作成したインスタンスをVueのインスタンス作成時にrouterに指定します。
これでVue.jsがvue-routerを使ったルーティングを行ってくれるようになります。

main.js

import Vue from 'vue'
import App from './App'
import VueRouter from 'vue-router'
import routes from './routes'

Vue.use(VueRouter) // VueRouterを使うことをVueに知らせる

const router = new VueRouter(routes) // ルーターインスタンスの作成

new Vue({
  el: '#app',
  template: '<App/>',
  components: { App },
  router // router にルーターインスタンスを指定
})

このルーターインスタンスは、
各コンポーネントの
$routerプロパティとして参照できるようになります。

$routerはナビゲーションを行うためのAPIを持っているので、
コンポーネントからJavaScriptによるナビゲーションを行うことができます。

プログラムによるナビゲーションについては、ドキュメントを参照してください。

# router-viewでコンポーネントを表示する

vue-routerをインストールすると、
<router-view>と<router-link>という、
ルーティングを行うための特別な要素が使えるようになります。

src/routers.jsにルーティングとコンポーネントをマッピングする設定を記述しましたが、

このマッピングしたコンポーネントを表示するのに<router-view>を使います。

<router-link>については後述します。

src/App.vueの<template>を次のように変更します。

App.vue

<template>
  <div id="app">
    <!-- router-viewに書き換える -->
    <router-view></router-view>
  </div>
</template>

router-viewには、
設定したルーティングにマッチした場合に
マッピングしたコンポーネントが表示されることになります。

# 各ページへのナビゲーションを行うコンポーネントを作成する

各ページへのナビゲーションを行うためのNavLinkコンポーネントを作成しましょう。
src/components/NavLink.vueとして保存します。

router-linkは
vue-routerでルーティングされるページへのリンクを張るための要素です。
router-linkにはリンク先のパスをそのままto="/items"と指定することもできますが、
:to="{name: 'root-name'}"と名前を付けたルートのnameを指定するほうが、
相対パスなどを気にする必要がなくなるので、便利でわかりやすくなります。

NavLink.vue

<template>
  <nav>
    <router-link :to="{name: 'root'}">最新</router-link>
    <router-link :to="{name: 'items'}">一覧</router-link>
    <router-link :to="{name: 'add'}">追加</router-link>
  </nav>
</template>

NavLinkをApp.vueで表示するように変更します。

App.vue

...
<template>
  <div id="app">
    <!-- nav-linkを追加 -->
    <nav-link></nav-link>
    <router-view></router-view>
  </div>
</template>

<script>
// NavLinkのimport文に書き換え
import NavLink from './components/NavLink'
export default {
  ...
  components: {
    // NavLinkのみに書き換え
    NavLink
  }
}
</script>

これでリンクをクリックすることで
各ページにアクセスできるようになりました。
ただ、この段階では各ページ（.vueファイル）が空のままなので、
何も表示されません。

ページのテンプレートを変更する

ルーティングが正しく動作しているか確認するために、
各ページのコンポーネントのテンプレートを次のように変更します。

Root.vue

<template>
  <div>
    ルートページです。
  </div>
</template>

Items.vue

<template>
  <div>
    一覧ページです。
  </div>
</template>

Add.vue

<template>
  <div>
    追加ページです。
  </div>
</template>

ルーティングに設定したURLにアクセスすると、
URLの変更に合わせてマッピングしたコンポーネントが表示されるのが確認できます。

# 各ページにコンポーネントを表示する

各ページにコンポーネントを配置して、
一覧表示と、メモの追加・削除が行えるようにしましょう。

一覧ページ

まずはItems.vueで
ListViewを使ってメモの表示が行えるようにします。

Items.vueを次のように変更します。


Items.vue

<template>
  <div>
    <list-view :memos="memos" @remove="remove"></list-view>
  </div>
</template>

<script>
  import ListView from '../components/ListView'
  export default{
    props: {
      memos: Array
    },
    methods: {
      remove(id) {
        this.$emit('remove', id)
      }
    },
    components: {
      ListView
    }
  }
</script>

Items.vueは自身のデータとしてmemosを持っていないので
、propsでmemosを受け取る必要があります
。App.vueからmemosを渡すように<template>を変更します。

App.vue

<template>
  <div id="app">
    <nav-link></nav-link>
    <router-view :memos="memos" @add="add" @remove="remove"></router-view>
  </div>
</template>

ここでは
メモの追加と削除の処理が行えるように、
'add'イベントと'remove'イベントのイベントハンドラも追加しています。

# 追加ページ

次にAdd.vueでEditorViewを使ってメモの追加が行えるように、
Add.vueを次のように変更します。
ここでは$router.push()を利用して、
メモの追加処理のあとに/itemsへナビゲーションするようにします。

Add.vue

<template>
  <div>
    <editor-view @add="add"></editor-view>
  </div>
</template>

<script>
  import EditorView from '../components/EditorView'
  export default{
    methods: {
      add(data) {
        this.$emit('add', data)
        this.$router.push({name: 'items'}) //追加処理のあとに`/items`にナビゲーションする
      }
    },
    components: {
      EditorView
    }
  }
</script>

/addにアクセスして、
追加ボタンをクリックすると、/itemsへと遷移して、
追加したメモが表示されているのが確認できます。

# トップページに最新n件のメモを表示する

トップページでは、
新しく追加した順に、指定した件数だけメモが表示されるようにします。
Vue 1.x系にはビルトインのフィルタがあったので簡単にできましたが、
Vue 2.x系ではフィルタが用意されていないので、
自身でフィルタの処理を実装する必要があります。

ListViewにフィルタを実装する

まずはListViewに表示件数の指定と、表示順が指定できるようにしましょう。

ListView.vueで、
次のようにpropsでcountとsortを受け取るようにします。
そしてフィルタした結果を返すfilteredMemos
をcomputedに定義して、
表示するデータをmemosからfilteredMemosに変更します。

ListView.vue

<template>
  ...
      <!-- v-forをmemo in filteredMemosに変更  -->
      <list-item
        v-for="memo in filteredMemos"
        :memo="memo"
        @remove="remove">
      </list-item>
  ...
</template>

<script lang="babel">
  import ListItem from './ListItem'
  export default{
    props: {
      memos: Array, // 書き換え
      count: Number, // 追加
      sort: String // 追加
    },
    computed: {
      hasMemo() {
        return this.filteredMemos && this.filteredMemos.length !== 0 // memosをfilteredMemosに書き換え
      },
      // filteredMemos()の処理を追加
      filteredMemos() {
        let memos = this.memos.concat()
        if (this.sort) {
          switch(this.sort) {
            case 'latest':
              memos.reverse()
          }
        }
        if (this.count) {
          memos = memos.splice(0, this.count)
        }
        return memos
      }
    },
    ...
  }
</script>

sortがlatestの場合にデータを逆順に表示できるようになり、
countで件数が指定できるようになりました。
なにも指定がない場合には処理を行わずにそのまま表示されます。

# Root.vueを変更する

Root.vueは次のように、
ListViewに対してcount: 3と、sort: "latest"を指定します。

リストの後ろには/itemsへのリンクを追加します。

Root.vue

<template>
  <div>
    <list-view :memos="memos" @remove="remove" :count="count" :sort="sort"></list-view>
    <router-link :to="{name: 'items'}">すべて見る</router-link>
  </div>
</template>

<script>
  import ListView from '../components/ListView'
  export default{
    data() {
      return {
        count: 3,
        sort: 'latest'
      }
    },
    props: {
      memos: Array
    },
    methods: {
      remove(id) {
        this.$emit('remove', id)
      }
    },
    components: {
      ListView
    }
  }
</script>

/にアクセスすると、次のように新しい順に指定した件数だけメモが表示されます。

# ナビゲーションにスタイルを追加する

NavLinkを左サイドに表示するようにスタイルを記述していきます。

.vueファイルでSassを使えるようにする

スタイルの変更の前に、
スタイルの記述を楽にするために、.vueファイルでSassを使えるようにしておきます。

必要なのはnode-sassとsass-loaderの2つのパッケージです。
次のコマンドで2つのパッケージをインストールします。

$ npm install --save-dev node-sass sass-loader

必要なのはパッケージのインストールだけで、
設定は特に必要ありません。

スタイルを追加する

NavLink.vueを次のように変更します。
<style>の中でSass（ここではSCSS記法）が使えるように、
langにscssを指定します。

NavLink.vue

<style scoped lang="scss">
  .menu {
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    background-color: #555;
    color: #fff;
    a {
      color: inherit;
      text-decoration: none;
      display: inline-block;
      padding: 10px;
      font-weight: normal;
      font-size: 14px;
      &:link {
        color: inherit;
      }
    }
    a.router-link-active {
      background-color: #fcfcfc;
      color: #555;
    }
  }
</style>

<template>
  <nav class="menu">
    <router-link :to="{name: 'root'}">最新</router-link>
    <router-link :to="{name: 'items'}">一覧</router-link>
    <router-link :to="{name: 'add'}">追加</router-link>
  </nav>
</template>

vue-routerはrouter-linkに設定されているルーティングが、現在のURLとマッチする要素にrouter-link-activeというクラスを付与します。
このクラスにスタイルを設定することで、
現在地がどこかを示すことができます。

ただしこの判定は、
URLの先頭からの部分一致なので、/はすべてのルートにマッチしていると判定されてしまいます。
URLが完全一致したときだけクラスが適用されるように、router-link要素にexact属性を追加します。

...
<router-link :to="{name: 'root'}" exact>最新</router-link>
...

# App.vueにスタイルを追加する

ナビゲーションが左サイドに固定されるように、
App.vueを次のように変更します。router-viewにはcontentsクラスを指定します。

App.vue

<style lang="scss">
  @import '../static/styles.css';
  html, body {
    color: #555;
    margin: 0;
    padding: 0;
    height: 100vh;
  }
  #app {
    height: 100%;
    display: flex;
    .contents {
      height: 100%;
      flex-grow: 1;
      overflow: scroll;
      box-sizing: border-box;
    }
  }
</style>
<template>
  <div id="app">
    <nav-link></nav-link>
    <router-view class="contents" :memos="memos" @add="add" @remove="remove" :count="3"></router-view>
  </div>
</template>
...

これで左サイドに固定ナビゲーションが表示されるようになり、よりアプリケーションらしくなりました。

今回はvue-routerを使ったルーティングについて解説しました。

次回は、メモの編集が行えるページを、/itemsのサブルートとして作成していきます。

前回、vue-routerを使ってルーティングを行い、
3つのページを作成しました。
今回は、一覧ページで選択したメモを編集できるようにします。そのためには、次の手順を踏みます。

    vue-routerの設定で、
      編集ページを/itemsにネストする
    編集ページを実装する

# 編集ページのルーティング

前回、一覧ページを次のように/itemsでルーティングするようにしました。

routes.js

{
  path: '/items', component: Items, name: 'items'
}

ひとつのメモ（アイテム）が選択され、
編集画面になるときのルーティングを素直に追加すると、次のようになるかと思います。


routes.js

{
  path: '/items', component: Items, name: 'items'
},
{
  path: '/items/:id', component: Edit, name: 'edit'
}

/:idの部分はidに動的な値がくることを表しています。
/items/1や/items/2にアクセスしたとき、
このルーティングにマッチして指定したコンポーネントが表示されます。
この値はJavaScriptから
$route.params.idといった形式で参照することができます。

編集ページが独立したページであるなら上記のルーティングでよいのですが、
今回は使いやすさを考えて、
独立したページではなく、
次のように一覧ページ内に編集用のエディタが表示されるようにしたいと考えました。

編集ページが独立している場合、
メモの選択→編集ページ→戻る→一覧ページ→メモの選択といったアクションが必要になり、
使いやすいとはいえないUIになってしまいます。
上記のようなUIであれば、一覧からメモを選択、編集しやすくなります。

# ルーティングをネストする

vue-routerでは、
<router-view>でレンダリングされたコンポーネントが<router-view>を持つことができます。

次のようにchildrenにルーティングを追加することで、
ネストしたルーティングがマッピングできます。

ルーティング設定があるroutes.jsを書き換えます。
import文でEditorViewコンポーネントを読み込みます。
/itemsに:idをネストし、
そこにEditorViewコンポーネントをマッピングしています。

routes.js

// （省略）
import EditorView from './components/EditorView'

export default {
  mode: 'history',
  routes: [
    // （省略）
    {
      path: '/items', component: Items, name: 'items', children: [
        {
          path: ':id', component: EditorView, name: 'edit'
        }
      ]
    }
  ]
}

Items.vueに<router-view>を追加する

Itemsコンポーネントに次のように<router-view>要素を追加すると、
URLが/items/:idにマッチしたときにEditorViewが表示されます。
ここではレイアウトのためのスタイルも追加しておきます。

Items.vue

<style lang="scss">
  .layout-items {
    display: flex;
    &-left {
      flex-grow: 1;
      overflow: scroll;
    }
    &-right {
      border-left: 1px solid #bbb;
    }
  }
</style>

<template>
  <div class="layout-items">
    <list-view class="layout-items-left" :memos="memos"></list-view>
    <router-view class="layout-items-right"></router-view>
  </div>
</template>
...

URLバーから/items/3に直接アクセスすると、
次のようにListViewとEditorViewが横並びに表示されるのを確認できます。

# メモを選択して編集ページに遷移する

一覧ページのメモをクリックしたときに、
編集ページに遷移するようにしましょう。

まずListItemをクリックしたときに
'select'イベントが発生するようにします。
ListItemのdiv要素に@click="select(memo.id)"を追加します。
クリックされたメモのidを引数にして、'select'イベントを発生させます。

また、ここでは削除ボタンの部分を@click.stopと変更しています。
この.stopはv-onディレクティブのための特別なイベント修飾子です。

.stopを付けることで、削除ボタンをクリックしたときに、
イベントが伝搬してselectが一緒に実行されてしまうのを避けることができます。

ListItem.vue

<template>
  <!--  @clickを追加  -->
  <div class="list-item" @click="select(memo.id)">
    （省略）
    <div>
      <!--  @click.stopに変更  -->
      <button @click.stop="remove(memo.id)">
        削除
      </button>
    </div>
  </div>
</template>

<script>
  // （省略）
  methods: {
    remove(id) {
      this.$emit('remove', id)
    },
    // select()を追加
    select(id) {
      this.$emit('select', id)
    }
  }
  // （省略）
</script>

イベント修飾子にはほかにもevent.preventDefault()を呼び出す.preventや、
イベントハンドラを一度だけ実行する.onceなどがあり、

共通してよく使うような処理を書かずにすむようになっています。
イベント修飾子を使うことで、
イベントハンドラ内部からDOMイベントの処理を切り離すことができます。

# イベントを親コンポーネントへ伝える

'select'イベントをItemsまで伝えるために、
ListViewコンポーネントからも
'select'イベントを発生するように変更します。
<list-item>要素に@select="select"を追加します。

<list-item>からくる'select'イベントを受け取ったら、
同じようにidを引数にして'select'イベントを発生させます。
methodsにselect(id)を追記します。

ListView.vue

<template>
  <div class="list-view">
    <div v-if="hasMemo">
      <!--  @selectを追加  -->
      <list-item v-for="memo in filteredMemos"
        :memo="memo"
        @remove="remove"
        @select="select">
      </list-item>
    </div>
    （省略）
  </div>
</template>

<script>
  （省略）
    methods: {
      remove(id) {
        this.$emit('remove', id)
      },
      // select()を追加
      select(id) {
        this.$emit('select', id)
      }
    },
  （省略）
</script>

選択されたidを元にページ遷移する

pageディレクトリにあるItemsで'select'イベントを受け取って、ページを遷移するように変更します。

select()では$router.push()で編集ページに遷移させています。
このとき、ルーティングで設定した/items/:idの:idをparams.idとして渡します。
こうすることでidの値を元に動的にページ遷移を行うことができます。

Items.vue

...
<template>
  <div class="layout-items">
    <!--  @selectを追加  -->
    <list-view class="layout-items-left"
      :memos="memos"
      @remove="remove"
      @select="select"></list-view>
    <router-view class="layout-items-right"></router-view>
  </div>
</template>

<script>
    //（省略）
    methods: {
      remove(id) {
        this.$emit('remove', id)
      },
      // select()を追加
      select(id) {
        this.$router.push({name: 'edit', params: {id}})
      }
    },
    //（省略）
</script>

# 選択したメモの内容をEditorViewで表示する

EditorViewが表示されるようになりましたが、
テキストボックスなどの中身が空です。
EditorViewで選択したメモの内容が表示されるように変更します。

# <router-view>に選択したメモのデータを渡す

Itemsから選択したメモのデータを<router-view>に渡します。

選択したメモのidと一致するメモをmemosの中から探して返すselectedMemoを、acomputedに定義します。
合わせて、<router-view>のpropsとして:memo="selectedMemo"とデータを渡すようにします。

Items.vue

<template>
  <div class="layout-items">
    <list-view class="layout-items-left"
      :memos="memos"
      @remove="remove"
      @select="select"></list-view>
    <router-view class="layout-items-right" :memo="selectedMemo"></router-view>
  </div>
</template>

<script>
    // （省略）
    props: {
      memos: Array
    },
    computed: {
      selectedMemo() {
        if (this.$route.params.id !== undefined) { // id がある場合は `/items/:id` へのアクセス
          const id = parseInt(this.$route.params.id, 10)
          const memo = this.memos.find((memo) => {
            return memo.id === id
          })
          return memo // id が一致するメモのデータを返す
        }
      }
    },
    //（省略）
</script>

propsで受け取ったmemoを表示する

ItemsからEditorViewに渡されたmemoを表示するように、EditorViewを変更します。

まずpropsでmemoを受け取るようにします。
EditorView.vue

<script>
  export default {
    props: {
      memo: Object
    },
    // （省略）
  }
</script>

次に、受け取ったmemoをthis.inputの各項目に入れるsetMemo()を、methodsに追加します。

memoを受け取ったときにはその内容を表示し、
memoを受け取っていなければdataに定義したものを使うようにします。

EditorView.vue

<script>
  export default {
    // （省略）
    methods: {
      // （省略）
      setMemo() {
        if (this.memo) {
          Object.assign(this.input, this.memo, {tags: this.memo.tags.join(' ')})
        }
      }
    }
  }
</script>

次に、コンポーネントのcreatedフックのタイミングでsetMemo()を実行するようにします。

EditorView.vue

<script>
  export default {
    // （省略）
    created() {
      this.setMemo()
    }
  }
</script>

ここまでの変更で、
一覧からメモを選択することで編集ページへと遷移し、
選択したメモの内容が表示されるようになりました。
しかしながら、
メモを連続して選択してみると初回の遷移で表示されたメモが更新されず、
そのまま表示されています。

例として/items/1から/items/2に遷移したときを考えてみます。

URLには変更がありますが、このときvue-routerはコンポーネントのインスタンスを破棄することなく、再利用します。

そのため、前述したcreatedフックに指定したメソッドが実行されず、propsで渡されたmemoが更新されても、
そのデータをセットする処理が行われないということです。

この問題を解決するにはいくつかの手法が考えられますが、
今回はmemoの値が変わったらsetMemo()が実行されるようにします。

# 値の変更を監視して処理を実行する

値の変更を監視するには、
watchオプションを利用します。
EditorViewにwatchを追加してmemoの変更があったときにsetMemo()が実行されるようにします。

EditorView.vue

<script>
  export default {
    // （省略）
    created() {
      this.setMemo()
    },
    watch: {
      memo: 'setMemo'
    }
  }
</script>

これでmemoが更新されるたびにsetMemo()が実行されるようになります。

# 更新処理を追加する

EditorViewに表示された項目を変更して、
保存ボタンをクリックしてもデータは更新されず、何も起こりません。
更新処理を追加しましょう。

Items.vueにある編集画面を表示する<router-view>要素に、
@add="update"を追加します。

さらにmethodsにupdate()を追加します。
保存ボタンをクリックしたときに発生する'add'イベントをItemsで受け取り、
受け取ったデータを'update'イベントとしてAppに伝えます。

ここでは'update'イベントを発生させたあと、
一覧ページへと遷移させるようにしています。

Items.vue

...
<template>
    <!-- （省略） -->
    <router-view class="layout-items-right"
      :memo="selectedMemo"
      @add="update">
    </router-view>
  </div>
</template>

<script>
  // （省略）
  methods: {
    // （省略）
    update(data) {
      this.$emit('update', data)
      this.$router.push({name: 'items'})
    }
  },
  // （省略）
</script>

<<<<<<< HEAD
これでメモの編集をキャンセルして、一覧ページへと戻れるようになりました。

今回は一覧ページのサブルートとして編集ページを追加し、
メモの編集が行えるようにしました。
データの追加だけでなく、編集が行えるようになって、
アプリケーションらしくなりました。

次回はVue.jsアプリケーションの状態管理の方法について、検討・解説します。

# Vue.jsと状態管理

まず、Vue.jsにおける状態（State）とは、
何かを明らかにしておきましょう。
=======
# Appでメモの更新を行う

Appで'update'イベントを受け取ったら、
該当するメモのデータを更新する処理を追加します。
<router-view>要素に@update="update"追加します。

methosにはupdate()を追加し、
'update'イベントを受け取ると、
update()が実行され、該当するメモをmemosから探し、受け取ったデータで更新するようにします。

App.vue

<template>
  <div id="app">
    <nav-link></nav-link>
    <router-view class="contents" :memos="memos" @add="add" @remove="remove" :count="3" @update="update"></router-view>
  </div>
</template>

<script>
  // （省略）
  methods: {
    // （省略）
    update(data) {
      const id = parseInt(data.id, 10)
      const index = this.memos.findIndex((memo) => {
        return memo.id === id
      })
      this.memos.splice(index, 1, data)
    }
  },
  // （省略）
</script>

# 戻るボタンの追加とidの表示

EditorViewに一覧ページに戻るボタンを追加します。
このボタンはpropsでmemoにデータが渡されている場合にのみ、
表示されるようにします。合わせて、memoがある場合にのみinput.idを表示します。
idは編集できないようにdisabled属性を付与し、
スタイルで枠線を消して編集可能な項目と区別できるようにしておきます。

methodsにcancel()を追加します。

EditorView.vue

<style scoped>
  input:disabled {
    border-color: transparent;
  }
</style>

<template>
  <div class="editor-view">
    <!--  IDのdiv要素を追加  -->
    <div v-if="memo">
      <label>ID：</label>
      <input v-model="input.id" disabled>
    </div>
    <!-- （省略） -->
    <div>
      <!--  戻るボタンを追加  -->
      <button @click="cancel" v-if="memo">戻る</button>
      <button @click="save">保存</button>
    </div>
  </div>
</template>

<script>
    // （省略）
    methods: {
      // （省略）
      cancel() {
        this.$emit('cancel')
      }
    },
    // （省略）
</script>

戻るボタンをクリックすると、
cancel'イベントが発生するので、Items.vueで受け取って、
一覧ページへと遷移するようにします。

Items.vue

<template>
  <!-- （省略） -->
  <router-view class="layout-items-right"
    :memo="selectedMemo"
    @add="update"
    @cancel="cancel"></router-view>
  <!-- （省略） -->
</template>

<script>
    // （省略）
    methods: {
      // （省略）
      cancel() {
        this.$router.push({name: 'items'})
      }
    }
    // （省略）
</script>

これでメモの編集をキャンセルして、一覧ページへと戻れるようになりました

今回は一覧ページのサブルートとして編集ページを追加し、
メモの編集が行えるようにしました。
データの追加だけでなく、編集が行えるようになって、アプリケーションらしくなりました。

前回までで、メモアプリケーションの機能の実装は完了しました。

今回は、アプリケーションの状態（State）の管理について、実装を混じえながら解説していきます。

# Vue.jsと状態管理

まず、Vue.jsにおける状態（State）とは、何かを明らかにしておきましょう。
>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c
Vue.jsの状態とは、Vueインスタンスのdataオブジェクトのことを指します。

前回作ったメモアプリケーションでいうと、
Appはdataオブジェクトにメモのコレクションの配列としてmemosという状態を持っていました。

<<<<<<< HEAD

=======
>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c
App.vue

  data() {
    return {
      memos: [
        ...
      ]
    }

<<<<<<< HEAD
また、EditorViewは
ユーザーからの入力を保持するためのinputという状態を持っていました。
=======
また、EditorViewはユーザーからの入力を保持するためのinputという状態を持っていました。

>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c

EditorView.vue

    data() {
      return {
        input: {
          text: '',
          date: '',
          tags: ''
        }
      }
    },

<<<<<<< HEAD
=======

>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c
これらの状態は、
必ずしもVueインスタンスやコンポーネントが持っている必要はなく、
状態をどう扱うかはアプリケーションの作成者に委ねられています。

# なぜ状態管理が重要なのか

<<<<<<< HEAD
前回作ったような、
小規模なアプリケーションであれば、
どこでデータの更新が行われているか把握することは簡単です。
コンポーネント同士が密なやり取りをしていたとしても、
特に大きな問題となるようなこともありません。
アプリケーションでエラーが起こったときも、どこに問題があるかを調査するのに、
それほど時間はかからないでしょう。
=======
前回作ったような、小規模なアプリケーションであれば、
どこでデータの更新が行われているか把握することは簡単です。

コンポーネント同士が密なやり取りをしていたとしても、特に大きな問題となるようなこともありません。

アプリケーションでエラーが起こったときも、
どこに問題があるかを調査するのに、それほど時間はかからないでしょう。
>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c

しかし、アプリケーションの規模が大きくなるにつれて、
データの更新を行っている箇所が増え、
各コンポーネントが好き勝手にアプリケーションの状態を変更していくと、
<<<<<<< HEAD
次第にアプリケーション全体のデータの流れを把握することが困難になります。

変更に強いアプリケーションを作るためには、
=======

次第にアプリケーション全体のデータの流れを把握することが困難になります。

変更に強いアプリケーションを作るためには、

>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c
変更に耐えられる状態管理を行う必要があります。

# 破綻しやすい状態管理の例

まず、Vue.jsのアプリケーションにおいて、
破綻しやすい状態管理の例を見てみましょう。

<<<<<<< HEAD
Vue.jsは単一の状態を、複数のVueインスタンスで共有することができます。
たとえば、次のようにすることで、
異なるVueインスタンスで同一のデータを参照することができます。
=======
Vue.jsは単一の状態を、
複数のVueインスタンスで共有することができます。
たとえば、
次のようにすることで、異なるVueインスタンスで
同一のデータを参照することができます。
>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c

app.js

const dataSource = {
  message: 'Hello Vue.js!!'
}

const vm1 = new Vue({
  el: '#vm1',
  template: `
<<<<<<< HEAD
    <div> 
=======
    <div>
>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c
      <input v-model="message">
    </div>
  `,
  data() {
    return dataSource
  }
})

const vm2 = new Vue({
  el: '#vm2',
  template: `
    <div>
      <p>{{message}}</p>
      <button @click="clear">clear</button>
    </div>
  `,
  data() {
    return dataSource
  },
  methods: {
    clear() {
      this.message = ''
    }
  }
})

document.querySelector('#button').addEventListener('click', (e) => {
  dataSource.message += 'button clicked!!'
})

vm1とvm2は、
dataオブジェクトでdataSourceという単一のデータを共有します。
<<<<<<< HEAD
次のデモでテキストボックスの編集と、
'clear'ボタンと'change'ボタンをそれぞれクリックしてみてください。

v-modelへの対処

Storeパターンを適用するにあたっては、
ポイントがあります。

破綻しやすい例で<input v-model="message">としていた箇所は、
v-modelディレクティブを通してmessageを直接変更していました。
これを<input v-model="sharedState.message">としてしまうと、
"状態はActionによってのみ変更される"という制約を破ることになってしまいます。

これを避けるために、
前述した例では:valueに値をバインドし、
'input'イベントが起こるたびにsetMessageActionを呼ぶように変更しています。

app.js（抜粋）

...
template: `
  <div> 
    <input :value="sharedState.message" @input="updateMessage">
  </div>
`,
...
methods: {
  updateMessage(e) {
    store.setMessageAction(e.target.value)
  }
}
...

# Storeパターンの効能

この単純なStoreパターンでは、
Storeを見ればアプリケーションにどういった状態が存在しているかを、
すぐに把握できます。
また、同じように状態の変更を行う関数も一箇所に集約されているので、
後からプロジェクトに参加した人でも、すぐに全体を把握できるでしょう。
先に決めておいた制約の共有がしっかりできれば、
人によって状態変更のやり方がバラバラになる、といったことも避けられます。

ただし、この単純なStoreパターンが有効なのは
、規模の小さなアプリケーションまでです。
管理する状態が増えるほど、状態の変更を行う関数も増え、
全体を把握するのが難しくなっていきます。
規模に合わせて状態とActionを、
ファイルとして分割できるような仕組みやプロセスの導入が必要になるでしょう。

Vue.jsは規模に合わせて、
段階的にスケールする仕組みをライブラリとツールで実現できます。

【コラム】フロントエンドの設計

Storeパターンなどがフォーカスされてきた背景としては、
近年のWebアプリケーションにおいて、フロントエンドに求められる部分が大きくなったことがあります。
特に、UIがリッチになったことでUI操作によるイベントが頻発するようになり、
今まで用いられていたMVCやMVVMといった設計がマッチしないケースが出てきました。
このようなイベントをうまく処理するための設計として、
Facebookが提唱したfacebook/Fluxのような状態管理のパターンも注目を集めています。

前回までで、メモアプリケーションの機能の実装は完了しました。
今回は、アプリケーションの状態（State）の管理について、実装を混じえながら解説していきます。

Vue.jsと状態管理

まず、Vue.jsにおける状態（State）とは、
何かを明らかにしておきましょう。Vue.jsの状態とは、
Vueインスタンスのdataオブジェクトのことを指します。

前回作ったメモアプリケーションでいうと、
Appはdataオブジェクトにメモのコレクションの配列として
memosという状態を持っていました。

App.vue

  data() {
    return {
      memos: [
        ...
      ]
    }

また、EditorViewはユーザーからの入力を保持するためのinputという状態を持っていました。


EditorView.vue

    data() {
      return {
        input: {
          text: '',
          date: '',
          tags: ''
        }
      }
    },

これらの状態は、必ずしもVueインスタンスやコンポーネントが持っている必要はなく、
状態をどう扱うかはアプリケーションの作成者に委ねられています。

今回は状態管理が破綻しやすい例と、
中央集権的な状態管理の方法であるStoreパターンについて解説しました。
次回は、メモアプリケーションに、実際にStoreパターンを適用していきます。

前回、状態管理について破綻しやすい例とStoreパターンについて解説しました。
今回は、メモアプリケーションの状態管理をStoreパターンで置き換えます。

store.jsの作成

まず、空のファイルをsrc/store.jsとして保存します。
store.jsは状態を格納するstateと状態を変更するactionsの2つを、
まとめてexportするようにします。

stateを定義する

アプリケーションの状態はstateに格納します。次のようにstateを定義します。

store.js

const state = {
  memos: []
}

メモアプリケーション全体として必要な情報はmemosのみになります。
ほかの状態はコンポーネントのプライベートな状態として定義します。

# actionsを定義する

状態の変更を行うActionをまとめたactionsを、次のように定義します。

actionsにはメモの追加（addMemo）、
メモの削除（removeMemo）、メモの編集（updateMemo）
という3つのActionが定義されています。

状態の変更を行うactionsの定義（store.js）

...
const actions = {
  addMemo(newMemo) {
    // memos の中のメモで一番大きい id に 1 を足した値を取得する
    newMemo.id = state.memos.reduce((id, memo) => {
        return id < memo.id ? memo.id : id
      }, 0) + 1
    state.memos.push(newMemo)
  },
  removeMemo(id) {
    const targetId = parseInt(id, 10)
    // memos の中から id が一致するメモの index を取得する
    const index = state.memos.findIndex((memo) => {
      return memo.id === targetId
    })
    state.memos.splice(index, 1)
  },
  updateMemo(memo) {
    const targetId = parseInt(memo.id, 10)
    // memos の中から id が一致するメモの index を返す
    const index = state.memos.findIndex((memo) => {
      return memo.id === targetId
    })
    state.memos.splice(index, 1, memo)
  }
}

デバッグ用の出力を追加する

各Actionが呼ばれたことがわかるように、
3つのActionそれぞれにデバッグ用の出力処理を追加します。
次のように、デバッグ用の出力を行うかどうか判定するためのdebugを定義して、
debugがtrueのときにconsole.log()でどのActionが呼ばれたかを出力します。


デバッグ用の出力処理（store.js）

...
const debug = process.env.NODE_ENV !== 'production'
const actions = {
  addMemo(newMemo) {
    debug && console.log(`addMemo triggered with`, newMemo)
    // 変更なし
  },
  removeMemo(id) {
    debug && console.log(`removeMemo triggered with`, id)
    // 変更なし
  },
  updateMemo(memo) {
    debug && console.log(`updateMemo triggered with`, memo)
    // 変更なし
  }
}

process.env.NODE_ENVには、
vue-loader（webpack）がビルド時に使う環境変数が格納されています。
npm run devで実行したサーバーでは'development'が格納され、
npm run buildを実行したときには'production'が格納されます。
この変数を参照することで、開発時にだけ実行したい処理を実装できます。
ここではNODE_ENVが'production'以外のときにdebugがtrueになります。

NODE_ENVの値はconfig/dev.env.jsとconfig/prod.env.jsで設定されます。

同じ処理をユーティリティとして切り出す

メモを削除するremoveMemoと、メモを編集するupdateMemoは、
memosの中から該当するidを持ったメモのindexを探すという同じ処理を行っています。
このユーティリティのような関数はutilといったオブジェクトにまとめて定義すると、
Actionごとの処理がわかりやすくなり、修正が必要になったときも修正箇所を減らすことができます。

memos中から該当するidを持ったメモのindexを返す関数を、util.findIndexとして定義します。


特定のidを持つメモのindexを返す関数（store.js）

...
const util = {
  // memos の中から id が一致するメモの index を返す
  findIndex(memos, id) {
    const targetId = parseInt(id, 10)
    return memos.findIndex((memo) => {
      return memo.id === targetId
    })
  }
}

const debug = process.env.NODE_ENV !== 'production'
const actions = {
  addMemo(newMemo) {
    // 変更なし
  },
  removeMemo(id) {
    debug && console.log(`removeMemo triggered with`, id)
    const index = util.findIndex(state.memos, id)
    state.memos.splice(index, 1)
  },
  updateMemo(memo) {
    debug && console.log(`updateMemo triggered with`, memo)
    const index = util.findIndex(state.memos, memo.id)
    state.memos.splice(index, 1, memo)
  }
}

utilに定義する関数はstateを直接参照せずに、
引数として必要な値を受け取るようにしておくと、より使い回しがしやすくなります。

# stateとactionsをexportする

最後にstateとactionsをほかの箇所で使えるようにexportします。

最後にstateとactionsをほかの箇所で使えるようにexportします。

stateとactionsをexportする（store.js）

...
const actions = {
  // 変更なし
}
export default {
  state,
  actions
}

これでStoreの準備は完了です。
このStoreを、ページのコンポーネントから参照して利用します。

# Storeを利用する際のルール

Storeは次のようなルール（制限）を設けて利用します。

src/pageのコンポーネントでだけStoreをimportする

具体的なコードとしては、以下の3点がポイントとなります。

src/componentsのコンポーネントはStoreのstateを参照しない
src/componentsのコンポーネントはActionを実行しない
Actionはsrc/pageのコンポーネントが実行する

src/componentsの各コンポーネントは、
レンダリングに必要なデータをpropsで受け取るようにして、
Storeのstateを直接参照しないようにします。
また、Actionを実行せずに、現状のまま自身に$emit()を実行して、
親コンポーネントにイベントを伝えるようにします。
こうして、イベントは親コンポーネントで監視するようにします。

このルールはStoreとコンポーネントを疎結合にするためのもので、
コンポーネントの再利用性を高めることになります。
src/pageのコンポーネントは再利用することはないので、
Storeと密結合になっても問題ありません。

＃App.vueから不要な処理を削除する

状態はStoreで管理して、
状態の変更はpageのコンポーネントから実行するので、
これまでApp.vueで行っていた処理のほとんどが不要になります。
App.vueを次のように変更します。


src/App.vue

<style lang="scss">
  /* 変更なし */
</style>
<template>
  <div id="app">
    <nav-link></nav-link>
    <router-view class="contents"></router-view>
  </div>
</template>

<script>
import NavLink from './components/NavLink'

export default {
  name: 'app',
  components: {
    NavLink
  }
}
</script>

ここではdataとcomputedとmethodsを削除します。

また、<router-view>に渡していたpropsとイベントの監視もすべて削除します。
ここで削除した処理はsrc/pageのコンポーネントが行うように変更していきます。

Items.vueでStoreを参照する

次にsrc/pageのコンポーネントのひとつItems.vueを変更します。


src/page/Items.vue

<style scoped lang="scss">
  /* 変更なし */
</style>
<template>
  <div class="layout-items">
    <list-view class="layout-items-left"
      :memos="sharedState.memos"
      @remove="remove"
      @select="select"></list-view>
    <router-view class="layout-items-right"
      <!-- 変更なし  -->
      ></router-view>
  </div>
</template>
<script>
  import ListView from '../components/ListView'
  import store from '../store'
  export default{
    data() {
      return {
        sharedState: store.state
      }
    },
    computed: {
      selectedMemo() {
        const id = this.$route.params.id
        if (id !== undefined) {
          const memo = this.sharedState.memos.find((memo) => {
            return memo.id === parseInt(id, 0)
          })
          return memo
        }
      }
    },
    methods: {
      remove(id) {
        store.actions.removeMemo(id)
      },
      // 変更なし
      update(data) {
        store.actions.updateMemo(data)
        this.$router.push({name: 'items'})
      }
    },
    // 変更なし
  }
</script>

import storeでStoreをインポートします。

data.sharedStateとしてStoreのstateを参照して、
memosを参照していた箇所をsharedState.memosと変更します。

this.$emit()でApp.vueで処理をさせていたremoveとudpateを、
それぞれの処理に対応する
Action（store.actions.removeMemo()
と
store.actions.updateMemo()）の実行に置き換えます。

# Rootの変更

src/pageのRoot.vueも同じようにStoreを参照するように変更します。


src/page/Root.vue

<template>
  <div>
    <list-view
      :memos="sharedState.memos"
      @remove="remove"
      :count="privateState.count"
      :sort="privateState.sort"
    ></list-view>
    <router-link :to="{name: 'items'}">すべて見る</router-link>
  </div>
</template>

<script>
  import ListView from '../components/ListView'
  import store from '../store'
  export default{
    data() {
      return {
        sharedState: store.state,
        privateState: {
          count: 3,
          sort: 'latest'
        }
      }
    },
    methods: {
      remove(id) {
        store.actions.removeMemo(id)
      }
    },
    components: {
      ListView
    }
  }
</script>

propsで受け取っていたmemosへの参照を、
sharedState.memosに変更します。
もともとあったdataは、Items特有の状態なのでprivateStateに移します。

Add.vue

src/pageのAdd.vueも同じようにStoreを参照するように変更します。


src/page/Add.vue

<template>
  <!-- 変更なし -->
</template>

<script>
  import EditorView from '../components/EditorView'
  import store from '../store'

  export default{
    methods: {
      add(data) {
        store.actions.addMemo(data)
        this.$router.push({name: 'items'})
      }
    },
    // 変更なし
  }
</script>

storeをインポートして、
this.emit('add')を
store.actions.addMemo()に置き換えています。

アプリケーションを実行する
 
Storeへの置き換えが完了したので、
アプリケーションを実行してみましょう。
完成したアプリケーションのコードは、以下にあります。

アプリケーションを実行して、
メモの追加や削除を実行すると、
開発者ツールのコンソールに変更のログが出力されているのが確認できます。

今回はアプリケーションの状態管理をStoreパターンで置き換えました。
規模の大きくないアプリケーションであれば、
今回実装したような単純なStoreパターンでも十分に機能しますが、
もっとしっかりとしたアプリケーションを構築するためには、
状態管理のためのライブラリを導入することが求められます。

Vue.jsはReduxやfacebook/fluxのようなライブラリを使って状態管理を行うことが可能ですが、
VuexというVue.js専用の状態管理ライブラリがあります。
Vuexを使えばVue.jsにスムーズに状態管理の仕組みを組み込むことができます。

# Vuexとは

VuexはVue.js専用の状態管理ライブラリです。
Vuexを使うと、Storeパターンをより堅牢にしたような状態管理が行えるようになります。

Vuexが必要になるのは、
複雑な状態を持つシンプルではないSPAを構築する場合です。
Vuexは状態の管理に強い制約を課すことで、
アプリケーションの長期的な生産性を高めます。

あまり規模の大きくないアプリケーションにVuexを導入してしまうと、
ただ単に冗長なコードの記述を求められることなってしまいます。
シンプルなアプリケーションであれば、Vuexを使わなくても、
Storeパターンなどで十分に機能するでしょう。

# Vuexの登場人物

Vuexを導入する前に、
Vuexに関するキーワードを把握しておきましょう。

VuexのStoreは、次のように4つのプロパティで構成されます。


VeuxのStore

const store = new Vuex.Store({
  state,
  mutations,
  actions,
  getters
})


const store = new Vue.Store({
  state,
  mutations,
  actions,
  getters
})

state

stateはStoreパターンと同じように、
アプリケーションの状態そのものを定義します。

アプリケーションの状態は、このstateだけが持つようにする必要があります。

stateプロパティ

state: {
  message: 'Hello Vue.js!!'
}

mutations

mutationsは、
stateを変更する唯一の存在です。
stateの変更は、必ずmutationsに定義した関数によって行われる必要があります。

mutationsプロパティ

mutations: {
  updateMessage(state, {newMessage}) {
    state.message = newMessage
  }
}

また、mutationsに定義した関数は直接実行せず、
commit()という関数を使って呼び出します。


mutationsに定義した関数の呼び出し

store.commit('updateMessage')

mutationsに定義する関数では、
必ず同期的にstateを更新する必要があります。

これはmutationsが非同期だった場合に、
Vuexがstateの変更を追跡するのが困難になるためです。
非同期の処理は、次項で解説するactionsで行います。


# actions

actionsは、
commit()を使ってmutationsを呼び出す関数を定義します。

actionsプロパティ

actions: {
  updateMessage(context, {newMessage}) {
    context.commit('updateMessage', {newMessage})
  }
}

actionsに定義した関数も直接実行せず、
dispatch()という関数を使って呼び出します。

actionsに定義した関数の呼び出し

store.dispatch('updateMessage')

mutationsとは異なり、
actionsは非同期の処理を含むことができます。

たとえば、次のようなAPIからのレスポンスが必要な処理などを記述できます。

actionsには非同期処理も定義できる

actions: {
  updateUserStatus(context) {
    // getStatus() はユーザの最新のステータスを返す
    user.getStatus()
      .then((response) => {
        context.commit('updateUserStatus', response.userStatus)
      })
  }
}

# getters

gettersはS
tore用の算出プロパティ（computed）のようなものです。

たとえば、
次のようなユニークなidを持つアイテムの配列をstateが持っている場合に、
アイテムのidを指定して取り出せるような関数を定義する、といった使い方をします。

gettersの使用例

state: {
  items: [
    { id: 1, text: 'hoge'},
    { id: 2, text: 'fuga'}
  ]
},
getters: {
  getItemById: (state, id) => {
    return state.items.find(item => item.id === id)
  }
}

gettersに定義した関数は、
次のようにstore.gettersを参照して実行します。

gettersに定義した関数の呼び出し

const item = store.getters.getItemById(2)
console.log(item)
// => { id: 2, text: 'fuga'} が出力される
=======

次のデモでテキストボックスの編集と、
'clear'ボタンと'change'ボタンをそれぞれクリックしてみてください。

vm1のテキストボックスの値を変更すると、
vm2のmessageも更新されます。
'clear'ボタンをクリックするとテキストボックスの文字列もクリアされます。
また、'change'ボタンをクリックすると'button clicked'という文字列をmessageに追加しますが、
このようなVueのインスタンスと無関係な場所からの変更でも再レンダリングが行われます。

このデモはデータを一箇所で管理できていて、
どこからデータを更新したかに関わらず、
データの変更によってリアクティブにレンダリングが行われています
。一見すると簡単で便利に思えるかもしれません。
ですがこれは筋の悪い方法です。

この方法がなぜ破綻しやすいかというと、
ユーザーの入力と状態の更新がまとめて行われているからです。
また、状態を更新できる箇所が複数あることも好ましくありません。
アプリケーションに機能追加などを行っていくと、
どこからどういったデータの更新が行われるか、
次第に予測することも把握することもできなくなり、
機能の追加だけでなく、デバッグさえも難しいものにするでしょう。

# 状態の変更方法とデータの流れに制約を加える

前述した破綻しやすい例では、
状態の変更に何も制限がなかったため、それぞれが自由に状態を更新し、
データがどこから更新されてどこに影響を与えるかがわからなくなります。
アプリケーションが大きくなっていくと、すぐにデータの流れが複雑になり、メンテンナンスが難しくなります。

ではデータの変更が追えて、
データの流れが複雑にならないようにするにはどうするか、
その答えの一つが中央集権的な状態管理です。
そしてただ中央で状態を管理するのではなく、
状態の変更とデータの流れに制約を与えることで、変更に強い状態管理を実現します。

#  Storeパターンとは

中央集権的な状態管理のパターンは、
Storeパターンと呼ばれることが多いです。
Storeパターンの単純な例を見てみましょう。今回は次のような制約をもとに実装を行います。

    状態は単一のStoreで管理する
    状態はActionによってのみ変更される

この制約によって、
自然とデータの流れを一方向に制約することになります。

次のコードは、単純なStoreの実装です。
すべての状態はstateに格納されます。

xxxxActionという名前の関数がActionにあたります。
これらのActionによってのみ、状態の変更を行うようにします。

store.js

const store = {
  debug: true,
  // これがstate
  state: {
    message: 'Hello Vue.js!!'
  },
  setMessageAction(newValue) {
    this.debug && console.log(`setMessageAction triggered with ${newValue}`)
    // set state
    this.state.message = newValue
  },
  clearMessageAction() {
    this.debug && console.log('clearMessageAction triggered')
    // clear state
    this.state.message = ''
  }
}

ここではdebugがtrueの場合に、Actionが呼ばれたことをコンソールにログとして出すようにしています。

このStoreを、アプリケーションから参照するようにします。

app.js

// store.js はscriptタグで読み込まれている状態
const vm1 = new Vue({
  el: '#vm1',
  template: `
    <div>
      <input :value="sharedState.message" @input="updateMessage">
    </div>
  `,
  data() {
    return {
      sharedState: store.state
    }
  },
  methods: {
    updateMessage(e) {
      store.setMessageAction(e.target.value)
    }
  }
})

const vm2 = new Vue({
  el: '#vm2',
  template: `
    <div>
      <p>{{sharedState.message}}</p>
      <button @click="clear">clear</button>
    </div>
  `,
  data() {
    return {
      sharedState: store.state
    }
  },
  methods: {
    clear() {
      store.clearMessageAction()
    }
  }
})

store.stateへの参照はsharedStateといった名前を付けておくことで、
これがアプリケーション全体で共有する状態だということがわかるようにしておきます。

sharedStateは参照専用として、直接変更を行わないようにします。

sharedStateに変更を加える場合には、必ずActionを実行して変更します。
コンポーネント固有の状態がある場合には、privateStateといった名前を付けておくことで、状態を区別することができます。
>>>>>>> d69fb1163ece3b32a1fa000c2c8ce367a2e5a21c
