
# vuejs

Vue.jsはUIなどを組み立てるView層にフォーカスしたJavaScriptライブラリです。
Vue.jsの特徴として、
リアクティブなデータバインディング、
再利用性の高いコンポーネントによるUIの構築、
仮想DOMによる高速なレンダリング、
シンプルなAPIなどが挙げられます。
シンプルでわかりやすく作られているため、
少しの学習でもすぐアプリケーション作成に役立てることができます。

また、Vue.jsをサポートするライブラリやツール、
整備されたドキュメント類、Vue.jsユーザーのコミュニティやフォーラムなど、
開発を進める過程で助けとなるものが数多く用意されているのも魅力の一つです。

データバインディングを試してみよう

input要素にmessageがバインディングされ、
テキストボックスの内容を変えるとmessageの値が更新され、
同時にmessageを参照している{{message}}の内容が更新されます。

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <div id="app"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.2/vue.js"></script>
    <script>
      new Vue({
        el: '#app',
        template: `
          <div>
            <p><input v-model="message"></p>
            <p>{{message}}</p>
          </div>
        `,
        data: {
          message: 'Hello Vue.js!!'
        }
      })
    </script>
  </body>
</html>

JavaScriptのコードとしては10数行ですが、
これだけでDOMとデータの同期ができます。
このようにVue.jsではHTMLテンプレートを使った宣言的なデータバインディングが簡単に行えます。

高速なレンダリング

Vue.jsは2系から、
仮想DOMを採用しています。仮想DOMの採用によって、
ほかのフレームワークと比較しても、
より最適化された高速なレンダリングが可能になりました。
仮想DOMについては、使うときに特に意識せずとも、その恩恵を受けることができます。

公式ブログでは、
第三者の描画速度のベンチマーク結果をまとめたグラフが掲載されています。
Vanilla JavaScript（ライブラリを用いない素のJavaScript）の処理速度を1として、
その何倍の時間がかかるかを表したもので、
数値が低いほど処理速度が速いということになります。

あらゆる規模で使えるフレームワーク

公式サイトを見ると「The Progressive JavaScript Framework」という見慣れない用語があると思います。
これは作者のEvan You氏が提唱する
"Progressive Framework（プログレッシブ・フレームワーク）"という概念です。

アプリケーションは、多くの場合、作って終わりということはなく、
その後も開発が続けられます。要求に合わせて新しい機能を追加したり、
ときには仕様を変更したりと、
アプリケーションを成長させる必要があります。
アプリケーションの成長段階において、
採用したフレームワーク（ライブラリ）が要求に合わなくなるというのはよくある話です。
こういったアプリの成長に対応できるフレームワーク、
それがProgressive Frameworkという概念です。

Progressive Frameworkが意味しているのは、
Vue.jsがどのような規模、段階のアプリケーションにも対応できるということです。
Vue.js単体を見ると、小規模のアプリケーションに適しているように思いますが、
Vue.jsをサポートするツールやライブラリといったエコシステムの存在によって、
アプリケーションの要求に柔軟に対応することができます。

開発をサポートするツール

前述したように、
Vue.jsを使った開発ではアプリケーションの要求に合わせて、
Vue.jsをサポートするライブラリやツールを採用していくことなります。
vuejsのリポジトリには、多くのライブラリやツールがあります。

vue-cli

vue-cliはVue.jsのプロジェクトを始める際に、
プロジェクトの雛形を生成（scaffolding：本来の意味は「足場」）してくれるツールです。

vue-cliを使うと、
webpackやBrowserifyを使ったバンドル環境の設定、
ファイルに変更があったときに差分だけを再読込してくれるローカルサーバーの設定を自動で行ってくれます。

またこれには、
後述するvueifyやvue-loaderによる
単一コンポーネントでのアプリケーション開発を行える環境のセットアップも行ってくれます。

vueifyとvue-loader

Vue.jsは
UIをコンポーネント（部品）ごとに定義して、
それを組み立てることでアプリケーションを構築します。

このコンポーネントの定義をよりやりやすくするのが、
vueifyとvue-loaderです。

vueifyとvue-loaderは基本的に同じ目的を持ったものですが、
vueifyがBrowserifyを使ったもの、
vue-loaderがwebpackを使ったものという点が異なります。

コンポーネントは
.vueという独自の拡張子のファイルで生成し、
この中にコンポーネントのHTML、CSS、JavaScriptを定義します。

次のソースコードは.vueファイルの例です。

template要素にHTMLテンプレートを、
style要素にCSSを、
script要素にJavaScriptを記述します。

<template>
  <div class="my-component">
    <button @click="onClick">{{message}}</button>
  </div>
</template>

<style lang="scss" scoped>
  .my-component {
    color: tomato;
    button {
      border: 1px solid #000;
    }
  }
</style>

<script>
  export default {
    data() {
      return {
        message: 'Hello!!'
      }
    },
    methods: {
      onClick() {
        console.log(this.message)
      }
    }
  }
</script>

vueifyとvue-loaderは
単にコンポーネントごとにファイルを分けるだけでなく、
SassやBabelといった、
CSSプリプロセッサやJavaScriptトランスパイラへの対応も簡単に行えるようになっています。

styleのlang属性の値としてscssやstylusといった指定をすることで、
面倒な設定なしにCSSプリプロセッサを利用できます。
また、
デフォルトでBabelによるトランスパイルが行われるようになっているので、
ES2015などの構文を存分に利用することができます。

Vuex

中規模、大規模なアプリケーションになってくると、
状態（データ）をどこに持たせるのかが問題になったり、
コンポーネント同士でデータのやり取りをしていたために、
コンポーネントの再利用性が低くなったりします。
このようなアプリケーションのデータに関する問題を解決するために利用するのが
Vuex（ビュエックス）です。

Vuexは、
Fluxに代表されるような状態管理パターンをVue.jsで行うためのライブラリです。

単一のState（状態）を
ActionsとMutationsによって変更し、
その変更をきっかけにVue ComponentsがUIの更新を行います。

Vuexを使うことで、
複雑になりがちなデータの管理を
シンプルにわかりやすく行えます。

そのほかの連携ライブラリ

Vue.jsは
ルーティングや通信の機能を持っていません。
Single Page Applicationを作るときなどには、
次に紹介するライブラリを使うことができます。

vue-router

vue-routerは
Vue.js公式のルーティングライブラリです。
公式のライブラリだけあって、
Vue.jsのコンポーネントを利用することに最適化されています。

vue-validator

vue-validatorは
Vue.js公式のフォームバリデーションライブラリです。
フォームに入力された値が期待している値かどうかチェックすることができます。

組み合わせるライブラリの選択

Vue.jsの公式ライブラリを紹介しましたが
「公式が提供しているものを使わなければならない」ということはありません。
公式ライブラリを使うことの利点は、
Vue.js本体の更新に合わせてライブラリも更新されることです。
サードパーティ製のライブラリは更新が突然止まって、
Vue.js本体の更新に追いつけなくなったり、
Vue.jsと組み合わせて使うのに適さなくなる可能性があります。

ただし、これはVue.jsのコア領域に関わるようなライブラリにだけ当てはまります。

たとえば、
外部リソースを取得するライブラリは
Vue.jsのコア領域には関わりがありません。
ですのでaxiosや、
それこそjQuery（の$.ajax）などの、
サードパーティ製ライブラリを自由に選択することができます。

Vue.jsの特徴と、
Vue.jsをサポートするツールやライブラリについて紹介しました。
次回はVue.jsのAPIの中から、特に使用頻度が高いものについて解説します。

Vue.jsのインストール

まずはVue.jsを使えるようにしましょう。
Vue.jsはGitHubリポジトリのreleaseページからダウンロードする方法、
CDNを使う方法、npmでインストール方法があります。

npmからインストールする場合には、コマンドラインから次のコマンドを実行します。

$ npm install vue

またほかの方法としてvue-cliを使ってテンプレートとともに環境を構築する方法もあります。

vue-cliの利用

vue-cliを次のように
-gオプションを付けてインストールします。

$ npm install -g vue-cli

インストール完了後、vueコマンドが使えるようになります。
新しくプロジェクトを作成する際には次のようにvue initを実行することで、テンプレートをダウンロードすることができます。

$ vue init <template-name> <project-name>

<tempalte-name>には
公式が提供しているテンプレートの名前と、
GitHubのリポジトリが指定できます。
筆者は公式が提供している次の2つのテンプレートのうちのどちらかを利用することをお勧めします。

    webpack
    browserify

これらのテンプレートを使うと、
.vueファイルによるコンポーネントの作成、ローカルサーバーによる部分的なモジュールの更新など、
開発を進める上で便利な環境がすぐに利用できるようになります。

準備ができたところで、
次節以降ではVue.jsの基本中の基本をおさえていくことにしましょう。

VueインスタンスとDOM要素を紐付ける

Vue.jsは作成したVueインスタンスを
DOM要素と紐付けることで機能します。
インスタンスを紐付けるにはelオプション、
もしくは$mount()を使います。

説明のために、
ここではHTML上に<div id="app"></div>という要素が存在する、
という前提で進めます。

<div id="app"></div>

elオプションを使って
idがappである要素にVueインスタンスを紐付けるには、
次のようにelにCSSのセレクタ#appを指定します。

const vm = new Vue({
  el: '#app',
  template: `<div>
    app
  </div>`
})

これは$mount()を使って次のように記述できます。

const vm = new Vue({
  template: `<div>
    app
  </div>`
})

vm.$mount('#app')

デモでは紐付けただけの状態なので、
ブラウザ上にappと表示されるだけです。

elオプションと$mount()にはCSSセレクタ以外にも、
doument.querySelector()などで取得できるDOM要素も指定できます。

State（状態）を持たせる

Vueインスタンスやコンポーネントに
Stateを持たせるには、次のようにdataオプションを使います。
ここではmessageというプロパティを定義しています。

const vm = new Vue({
  el: '#app',
  template: `<div>
    {{message}}
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!'
    }
  }
})

Stateはtemplateから{{}}（Mustache記法）で参照することができます。
templateから参照している値は、Stateが更新された際に自動的に表示も更新されます。

dataオプションの定義には、
オブジェクトをそのまま指定する方法と、
関数によってオブジェクトをreturnする方法の2つがあります。

メソッドを定義する

Vueインスタンスにメソッドを追加する場合には、
次のようにmethodsオプションに定義します。
ここではcountに1を足していくincrement()を定義しています。

const vm = new Vue({
  el: '#app',
  template: `<div>
    {{message}}:{{count}}
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!',
      count: 0
    }
  },
  methods: {
    increment() {
      this.count += 1
    }
  }
})

methodsや後述するcomputedなどからStateを参照する際には、
プロパティ名にthisを付けて参照します。
またdataで定義した値はthis.$dataという変数に格納されていますが、
これは省略することができます。

templateからメソッドを呼び出す

定義したincrement()を
templateから呼び出すには、v-onディレクティブを使います。

v-onディレクティブは
v-on:イベント名="メソッド名"という形式で記述します。
ボタンがクリックされたときにincrement()を呼び出すには、
v-on:click="increment"となります。
なお、以降、コードが重複する部分は省略して差分部分だけを示します。

...
  template: `<div>
    <button v-on:click="increment">increment</button>
    <div>{{message}}:{{count}}</div>
  </div>`,
...

ボタンをクリックするとincrement()が呼ばれ、countに加算された結果が表示されます。

v-onディレクティブは省略記法が用意されています。次のように@clickといった具合に、v-onを@で置き替えることができます。

...
  template: `<div>
    <button @click="increment">increment</button>
    <div>{{message}}:{{count}}</div>
  </div>`,
...

v-が付いたディレクティブが多く存在しているので、
テンプレートの見通しをよくするために
@による省略記法を使うことをお勧めします。

# 算出プロパティを利用する

プロパティ同士を計算した結果を表示したり、Stateによって条件判定を行うなど、なんらかの処理を加えた値を表示することがあります。こういった場合には、computedオプションを使います。

たとえば、computedオプションに、messageとcountを繋げた文字列を返すmessageAndCountプロパティを定義します。templateからこのプロパティを参照することで、テンプレート上で文字列を結合するような処理を書く必要がなくなります。

...
  template: `<div>
    <button @click="increment">increment</button>
    <div>{{messageAndCount}}</div>
  </div>`,

...

  computed: {
    messageAndCount() {
      return `${this.message}:${this.count}`
    }
  }
})

computedオプションで定義されたプロパティは、

プロパティ内部で使用されているプロパティ（ここではmessageとcount）が更新された場合に、
自動的に計算をし直して、表示する値も更新されます。

テンプレート上にはできるだけロジックを書かないようにすることが、
テンプレートの見通しをよくするためにも望ましいことです。

ここまでて、Vue.jsを用いたWebアプリケーション作成の基礎的な部分がおわかりいただけたかと思います。

次節からはディレクティブについて解説します。

# DOM操作を行うディレクティブ

Vue.jsには
ディレクティブ（directive）と呼ばれる、
DOM操作を行うための組み込みの機能が用意されています。
ディレクティブにはv-という接頭辞が付けられています。
Vue.jsには10種類を超えるディレクティブがありますが、こ
こではよく使うディレクティブについて解説します。

# イベントのハンドリングを行うv-on

v-onディレクティブは
DOM上で起こるイベントをハンドリングするためのディレクティブです。

前述したclick以外にも
submitやkeyupなど、DOM上で起こるイベントをハンドリングできます。
また、
次回以降解説する$emit()によるイベントのトリガーも
v-onを使ってハンドリングすることができます。

# フォーム要素で便利なv-model

v-modelディレクティブは
フォーム要素のvalueとVueインスタンスのStateをバインディングするディレクティブです。
次のようにinput要素にv-modelディレクティブでプロパティ名を指定すると、
テキストボックスの変更と合わせて指定したプロパティの値も更新されます。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div>{{messageAndCount}}</div>
  </div>`,
...

# 条件によってDOMの表示／非表示を切り替えるv-ifとv-show

特定の条件を満たすとき／満たさないときに、
要素の表示／非表示を切り替えたいときがあると思います。
そういったときには、v-ifディレクティブか
v-showディレクティブを使います。

v-ifディレクティブとv-showディレクティブは、指定された値（条件式）がtrueのときに要素を表示し、
値がfalseのときに要素を非表示にします。

例として、v-ifディレクティブを使って
countプロパティが奇数のときにだけmessageAndCountが表示されるようにしてみます。

次のように表示と非表示を切り替えたい要素にv-ifディレクティブで条件式を指定します。

ここでは2で割った余りが1になるとき（つまり奇数）のときに表示されるようにしています。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-if="count % 2 !== 0">{{messageAndCount}}</div>
  </div>`,
...

increment()を実行すると表示／非表示が交互に切り替わります。

# v-ifとv-showの違い

v-showディレクティブも
要素を非表示にするものですが、v-ifディレクティブとはいくつか異なる点があります。
v-ifディレクティブはfalseと評価される値が指定されたときにDOM上から要素を取り除くことで非表示にしますが、
v-showディレクティブはCSSのdisplayにnoneを指定して非表示にします。

また、v-ifディレクティブでは
falseと評価される値が指定されたときにだけ表示される要素をv-elseディレクティブで指定することができます。

次のように、v-ifディレクティブを指定した要素に隣接するように、
v-elseディレクティブを指定した要素を記述します。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-if="count % 2 !== 0">{{messageAndCount}}</div>
    <div v-else>この要素はcountが偶数のときに表示されます</div>
  </div>`,
...

ボタンをクリックすると、
v-ifディレクティブを指定した要素とv-elseディレクティブを指定した要素が交互に表示されます。

# 動的に属性値を割り当てるv-bind

classやstyleなど、
Stateや条件によって
動的に値を適用したいときがあります。
そうったときにはv-bindディレクティブを使います。

次の例はcomputedのプロパティとして
styleObjectというインラインスタイルのためのプロパティを定義しています。
colorはthis.countが奇数のときに'red'、偶数のときに'blue'になります。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-bind:style="styleObject">{{messageAndCount}}</div>
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!',
      count: 0
    }
  },
  methods: {
    increment() {
      this.count += 1
    }
  },
  computed: {
    messageAndCount() {
      return `${this.message}:${this.count}`
    },
    styleObject() {
      return {
        color: this.count % 2 !== 0 ? 'red' : 'blue',
        fontSize: '16px'
      }
    }
  }
...

この例ではcomputedオプションを使用していますが、
templateにそのまま記述することもできますし、dataのプロパティを参照することもできます。
v-bindはstyleやclassに限らず、
値を要素に動的にバインディングする場合、全般において使えます。

また、v-bindディレクティブには省略記法が用意されており、
v-bindを省略して:hoge="fuga"といった記述で指定することもできます。

# 繰り返し表示を行うv-for

配列やオブジェクトなど、
値が単一でないプロパティの表示には
v-forディレクティブを使います。
次の例では文字列を格納した配列colorsと、
オブジェクトを格納したusersを定義し、
v-forディレクティブによって表示しています。

...
  template: `<div>
    <input v-model="message">
    <button @click="increment">increment</button>
    <div v-bind:style="styleObject">{{messageAndCount}}</div>
    <div>colors:
      <span v-for="color in colors" :style="{color}">{{color}} </span>
    </div>
    <div>users:
      <div v-for="user in users">
        {{user.id}}:{{user.name}}
      </div>
    </div>
  </div>`,
  data() {
    return {
      message: 'Hello Vue.js !!',
      count: 0,
      colors: ['red', 'blue', 'green'],
      users: [
        {id: 1, name: 'ユーザ１'},
        {id: 2, name: 'ユーザ２'}
      ]
    }
  },
...

v-forはcolor in colorsといった形式で、
右側にVueインスタンスが持っているプロパティ名（ここではcolors）を指定し、
左側にはv-forの繰り返し内で参照できるように
エイリアス（ここではcolor）を指定します。

v-forディレクティブで
オブジェクトの値を繰り返し処理する場合、user.idのように参照することもできますが、
次のようにvalueとkeyをエイリアスとして指定することができます。

...
    <div>users:
      <div v-for="user in users">
        <span v-for="(value, key) in user">
          {{key}}:{{value}},
        </span>
      </div>
    </div>
  </div>`,
...

ここではv-for="user in users"としている繰り返し処理の中で、
さらに
v-forディレクティブを使い、v-for="(value, key) in user"として、
userプロパティが持っているプロパティのkeyとvalueを列挙しています。

このように、
v-forディレクティブを使うことで
繰り返し処理も簡潔に記述することができます。

次回から、アプリケーションを作りながらVue.jsの実践的な使い方について解説していきます。

まず今回作成していくサンプルアプリケーションの完成形の動作をデモで確認してみましょう。
デモを実行してどのような動作をするのかを把握してください。

内容、日付、タグを入力し、保存ボタンをクリックすると、ページ内にその内容が保存されます。

アプリケーションの構成

このアプリケーションは次の3つのコンポーネントで構成されています。

    メモを追加するEditorView

    メモを表示するListItem

    ListItemをリスト表示するListView

これら3つのコンポーネントを組み合わせて、メモアプリケーションとして動作するようにします。

そのほかの設計方針

このシリーズでは、
設計方針としてFlux的な状態管理の手法をベースに考えていきます。
コンポーネントは
親コンポーネントなどから与えられたデータを表示するのが主な役割となるので、
機能としての必然性がない限り、
コンポーネント独自の状態を持たせないようにします。
また、状態の変更が各コンポーネントに散らばらないように、
データの追加・削除・更新などの処理はコンポーネントでは行わず、
ルートのインスタンスで行うようにします。

今回のアプリケーションでは、
ListViewと
ListItemは独自の状態を持たず、
親コンポーネントから渡されたデータを表示するだけです。
EditorViewは
ユーザーの入力を必要とするので入力項目の状態を持たせますが、
メモを追加する処理はルートのインスタンスが行うようにします。

まずは
Vue.jsが動作するようにファイルを準備します。

ページのベースとなるHTMLとして、
次のHTMLをindex.htmlとして保存します。

index.html

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>vue-memo</title>
  <link rel="stylesheet" href="./styles.css">
</head>
<body>
  <div id="app"></div>
  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script src="components/ListItem.js"></script>
  <script src="components/ListView.js"></script>
  <script src="components/EditorView.js"></script>
  <script src="app.js"></script>
</body>
</html>

index.htmlでは
Vue.js本体と3つのコンポーネント、
後述するapp.jsを読み込むように記述しておきます。

合わせて、
デモ用のスタイルとして次のCSSをstyles.cssとして保存し、読み込むように指定しておきます。

次に、メインの処理を記述していくJavaScriptファイルとして、次のコードをapp.jsとして保存します。
app.js

const vm = new Vue({
  el: '#app',
  data() {
    return {}
  },
  template: `
    <div></div>
  `
})

app.jsにはid属性値がappである要素にVueインスタンスを紐付けるようにしておきます。

最後に、コンポーネントの処理を記述する3つのJavaScriptファイルを作成しておきます。これらのファイルは、この時点では空のままで大丈夫です。

    components/ListItem.js
    components/ListView.js
    components/EditorView.js

これらのファイルを作ると次のようなファイル構成になります。

.
├── app.js
├── components
│   ├── EditorView.js
│   ├── ListItem.js
│   └── ListView.js
├── index.html
└── styles.css

# Step1. ListItemコンポーネントでメモを表示する

まずは
メモの内容を表示するListItemコンポーネントの作成です。
ListItem.jsを次のように変更します。
ここでは表示のテスト用の値として、memoというプロパティに
メモの内容を持たせておきます。

ListItem.js

Vue.component('list-item', {
  data() {
    return {
      memo: {
        id: 1,
        text: 'テスト',
        date: '16-10-28',
        tags: ['タグ1', 'タグ2']
      }
    }
  },
  template: `
    <div class="list-item">
      <div>
        <span>id</span>：
        <span>{{memo.id}}</span>
      </div>
      <div>
        <span>text</span>：
        <span>{{memo.text}}</span>
      </div>
      <div>
        <span>date</span>：
        <span>{{memo.date}}</span>
      </div>
      <div>
        <span>tags</span>：
        <span>
          <span v-for="tag in memo.tags">{{tag}}</span>
        </span>
      </div>
    </div>
  `
})

ここではVue.component()を使い、
list-itemという名前でコンポーネントを登録しています。

このコンポーネントは、ほかのコンポーネントから<list-item></list-item>とすることで、

HTMLのカスタムタグのように使用できます。

memo.tagsは配列なので、
v-forディレクティブを使って繰り返し処理で値を表示します。

次にapp.jsでListItemコンポーネントを使うように、
template部分を変更します。
コンポーネントはVue.component()に指定した名前（list-item）をタグとして使います。

app.js

const vm = new Vue({
  el: '#app',
  data () {
    return {}
  },
  template: `
    <div>
      <list-item></list-item>
    </div>
  `
})

ここまでの状態です。実行すると、メモの内容が表示されます。

# Step2. EditorViewからメモを追加する

次にメモを追加するEditorViewコンポーネントを作成します。
EditorViewにはtext、date、tagsを入力するinput要素を定義し、
保存ボタンをクリックしたらsave()を実行するように変更します。

EditorView.jsを次のように変更します。

EditorView.js

Vue.component('editor-view', {
  template: `
    <div class="editor-view">
      <div>
        <label>内容：</label>
        <input v-model="input.text" placeholder="メモのタイトル">
      </div>
      <div>
        <label>日付：</label>
        <input type="date" v-model="input.date">
      </div>
      <div>
        <label>タグ：</label>
        <input v-model="input.tags" placeholder="空白区切りで指定">
      </div>
      <div>
        <button @click="save">保存</button>
      </div>
    </div>
  `,
  data() {
    return {
      input: {
        text: '',
        date: '',
        tags: ''
      }
    }
  },
  computed: {
    tagsArr() {
      // input.tags の文字列を空白で区切って配列に変換する
      return this.input.tags.trim() !== '' ? this.input.tags.trim().split(/\s+/) : []
    }
  },
  methods: {
    save() {
      // this.input のクローンを生成する
      const data = Object.assign({}, this.input, {tags: this.tagsArr})
      // 'add'イベントを自身にトリガーする
      this.$emit('add', data)
    }
  }
})

3つのinput要素はv-modelディレクティブで、
それぞれinputプロパティにバインディングしています。
save()はinputプロパティをクローンして処理を加えたあと、
$emit()で'add'イベントをトリガーします。
app.jsはこの'add'イベントをハンドリングして値を受取るように変更します。

app.jsで'add'イベントをハンドリングしてデータを受け取るように変更します。

コンポーネントからのイベントは、
v-onディレクティブでハンドリングすることができます。
ここではeditor-viewで
'add'イベントが発生したときにadd()を呼ぶように<editor-view @add="add">としています。

const vm = new Vue({
  el: '#app',
  data() {
    return {
      memo: {
        id: 1,
        text: '',
        date: '',
        tags: ''
      }
    }
  },
  template: `
    <div>
      <editor-view @add="add"></editor-view>
      <list-item></list-item>
    </div>
  `,
  methods: {
    add(newMemo) {
      Object.assign(this.memo, newMemo)
    }
  }
})

これでEditorViewから
メモのデータを受け取ることができるようになりましたが、
受け取ったデータをListItemに渡していないので表示できません。
受け取ったデータをv-bindをディレクティブを使ってListItemに渡すように、
templateを変更します。

app.js

...
template: `
  <div>
    <editor-view @add="add"></editor-view>
    <list-item :memo="memo"></list-item>
  </div>
  `
...

これでListItemコンポーネントmemoプロパティの値を渡すようにできましたが、
ListItemコンポーネントはmemoを受け取れるようになっていません。

コンポーネントは
propsオプションを使うことで値を受け取ることができます。
ここではpropsオプションを使い、memoという名前でObjectを受け取るという指定をします。
また、ListItemコンポーネントはpropsで受け取ったmemoを表示することを役割とするため、
dataは削除しておきます。

ListItem.js

Vue.component('list-item', {
  props: {
    memo: Object
  },
  template: `
    （変更なしのため省略）
  `
})

項目を埋めて保存ボタンをクリックすると、
propsで受け取ったデータが表示できていることが確認できます。

# Step.3 ListViewでメモをリスト表示する

次に複数のメモをリスト表示できるように、
ListViewコンポーネントを作成します。
ListViewコンポーネントはmemosというメモの配列をpropsで受取り、
ListItemで表示するようにします。
また、memosが空だった場合にはv-ifディレクティブを使って、
メモの代わりに表示できるメモがありません。
というメッセージを表示するようにします。

ListView.js

Vue.component('list-view', {
  template: `
    <div class="list-view">
      <div v-if="memos && memos.length !== 0">
        <list-item
          v-for="memo in memos"
          :memo="memo">
        </list-item>
      </div>
      <div v-else>
        表示できるメモがありません。
      </div>
    </div>
  `,
  props: {
    memos: Array
  }
})

ListViewコンポーネントにmemosを渡すようにapp.jsを変更します。
また、EditorViewから'add'イベントで受け取ったデータをmemosに追加するように変更します。

app.js

...
  data() {
    return {
      memos: []
    }
  },
  template: `
    <div>
      <editor-view @add="add"></editor-view>
      <list-view :memos="memos"></list-view>
    </div>
  `,
  methods: {
    add(newMemo) {
      newMemo.id = this.nextId
      this.memos.push(newMemo)
    },
  },
  computed: {
    nextId() {
      // this.memos の中で一番大きい id + 1 を返す
      return this.memos.reduce((id, memo) => {
          return id < memo.id ? memo.id : id
        }, 0) + 1
    }
  }
})

メモの追加時に、
追加するメモに対してidを設定しています。
computedのnextIdは
memosの中で一番大きいidに1を加えた数値を返します。

実行すると、項目を埋めて保存ボタンをクリックするごとにメモが追加されていくのが確認できます。

# Step.4 メモを削除できるようにする

もっとアプリケーションらしくするため、
追加したメモを削除できるようにしてみましょう。

ListItemコンポーネントに削除ボタンを追加し、
クリックされたときにremove()を呼ぶように変更します。

ListItem.js

...
template: `
  <div class="list-item">
    <div>
      <span>id</span>：
      <span>{{memo.id}}</span>
    </div>
    <div>
      <span>text</span>：
      <span>{{memo.text}}</span>
    </div>
    <div>
      <span>date</span>：
      <span>{{memo.date}}</span>
    </div>
    <div>
      <span>tags</span>：
      <span>
        <span v-for="tag in memo.tags">{{tag}}</span>
      </span>
    </div>
    <div>
      <button @click="remove(memo.id)">削除</button>
    </div>
  </div>
`,
methods: {
  remove(id) {
    // this.$parent(ListViewコンポーネント)に
    // 'remove' イベントをトリガーする
    this.$parent.$emit('remove', id)
  }
}
...

remove()ではListItemの親にあたるインスタンス（ListViewコンポーネント）に対して
'remove'イベントをトリガーするようにします。
こうすることで、app.jsでは次のように'remove'イベントをハンドリングすることができるようになります。

app.js

...
template: `
  <div>
    <editor-view @add="add"></editor-view>
    <list-view :memos="memos" @remove="remove"></list-view>
  </div>
`,
methods: {
  add(newMemo) {
    newMemo.id = this.nextId
    this.memos.push(newMemo)
  },
  remove(id) {
    // 該当する id を持つ要素の index を取得する
    const index = this.memos.findIndex((memo) => {
      return memo.id === id
    })
    // this.memos から index にある要素を削除する
    this.memos.splice(index, 1)
  }
},
...

メモを追加し、メモに表示されている削除ボタンをクリックすると、メモが削除されるのを確認できます。

今回は小さなアプリケーションの作成を通して、
コンポーネントの作成とデータの受け渡しや、
イベントハンドリングについて解説しました。
ここまでの内容を習得できれば、
Vue.jsを使って単純なアプリケーションが開発できるはずです。

vue-cliやvue-routerを使った、
本格的なSPAの作成を解説していきます。

# サンプルアプリケーションの概要

まず、これから本シリーズで
数回に渡って作成していくサンプルアプリケーションの完成形の動作を、
デモで確認してみましょう。
どういった実装になっているかはシリーズを通して段階的に解説していきますので、
まずはどのような動作をするのかを把握してください。

ページ構成

アプリケーションは大きくわけて3つのページがあります。
それぞれには次のようなURLと機能を割り当てています。
一覧ページはサブのページとして編集ページを持っています。

ページ名 	ルーティング 	機能

最新 	/ 	最新n件のメモの表示
一覧 	/items 	すべてのメモの一覧表示、メモの絞り込み表示
編集 	/items/:id 	メモの編集
追加 	/add 	新規メモの追加

次回以降、vue-routerを使ってこれらのページのルーティングを追加していきます。

コンポーネント構成

前回作成したアプリケーションと同様に、
アプリケーションは複数のコンポーネントで構成されています。
たとえば、一覧ページは次の図のようになっています。

これらのコンポーネントは、
前回作ったアプリケーションのコンポーネントを再利用しながら作ります。

コンポーネントには、
それぞれ特定の役割を持たせることになります。
ここで使われているコンポーネントは、次のような役割を持っています。

番号 	コンポーネント名 	役割

1 	ListView 	メモをリスト表示する
2 	ListItem 	メモの内容を表示する
3 	EditorView 	メモの追加・編集
4 	NavLink 	ページのナビゲーション

ListViewコンポーネントの中では、ListItemコンポーネントを使ってメモの内容を表示しています。
EditorViewは新規のメモの作成を行う機能を持っていますが、特定の条件を満たしたときにはメモを編集する機能を有効にします。
NavLinkは各ページへのリンクを提供します。

作成工程

これから数回に渡って、
このアプリケーションを作成していきます。
このアプリケーションは、前回作成したアプリケーションをベースにして、
次のような工程を経て完成させます。
メモアプリケーションに必要な機能（ソート、検索、絞り込み）なども適宜追加していきます。

    vue-loaderを使ったコンポーネントの
      .vueファイルへの置き換え
    vue-routerを使ったルーティングの追加

    vue-routerを使ったネストしたルーティングの追加

    アプリケーションの状態管理の変更

    Vuexを使った状態管理

今回の記事では、
最初の工程、vue-loaderを使ったコンポーネントの.vueファイルへの置き換えを解説します。

前回作成したアプリケーションでは、
Vue.component()を使って各コンポーネントを.jsファイルとして記述しました。
以降では、vue-loaderを使って各コンポーネントを.vueファイルで記述します。

# vue-devtoolsのインストール

環境構築に入る前に、
Vue.jsのアプリケーションをデバッグするのに役立つvue-devtoolsをインストールしておきましょう。

vue-devtools
はChrome専用の拡張機能で、
次のリンクからブラウザにインストールすることができます。

    Vue.js devtools - Chrome ウェブストア

インストールするとDevToolsに
Vueパネルが追加され、
アプリケーションやコンポーネントの状態が確認できるようになります。

# vue-cliで環境構築

それでは最初に、vue-cliを使って、
開発用のローカルサーバーやビルドの環境などを構築します。
vue-cliはVue.jsでの開発に必要なこまごまとしたツールを
一括で準備できる便利なツールです。

コマンドラインから
次のコマンドを実行して、vue-cliをグローバルにインストールします。

$ npm install -g vue-cli

インストール完了後、
次のコマンドを実行してvue-cliが正しくインストールされているのを確認します。
正しくインストールされていれば、次のようにバージョン番号が表示されます。

$ vue -V
2.5.1

テンプレートの利用

vue-cliは公式が提供しているテンプレートか、
ユーザーが作成したテンプレートが利用できます。
今回は公式が提供しているwebpackのテンプレートを利用します。
このテンプレートには、
次のような機能が使えるコマンドが用意されています。

    開発用ローカルサーバー：
        ファイルの監視と差分更新

    リリース用のビルド：
        minifyやバンドル

    .vueファイルによるコンポーネント作成

本シリーズでは解説しませんが、
ESLintによる構文チェックや、ユニットテストとE2Eテストなどのテスト環境の構築も行えます。

プロジェクトの作成

早速ですが、
次のコマンドを実行してwebpackのテンプレートを使ったプロジェクトを、
vue-memoという名前で作成します。

$ vue init webpack vue-memo

コマンドを実行すると、
package.jsonに指定するプロジェクトの名前や、
各ツールの使用可否をY/nで答えるように質問されます。
今回"Vue build"まではすべてエンターキーで進めて、
それぞれの質問には次のように回答します。

    ? Vue build: Runtime + Compiler (standalone)：そのままリターン
    ? Use ESLint to lint your code?: No：nを入力
    ? Setup unit tests with Karma + Mocha?: No：nを入力
    ? Setup e2e tests with Nightwatch?: No：nを入力

vue-cli · Generated "vue-memo".というメッセージが表示されたらプロジェクトの生成は完了です。

これだけでvue-loaderを使ったコンポーネントの開発、
ローカルサーバーによる差分更新、リリース用のビルドコマンドなどが行える環境が整えられました。

vue-memoのディレクトリに移動したあと、
npm installを実行して依存パッケージをインストールします。

ローカルサーバーを起動してみる

必要なパッケージのインストールが完了したので、
ローカルサーバーを起動してみましょう。プロジェクトのディレクトリで次のコマンドを実行してローカルサーバーを起動します。

$ npm run dev

正しく起動すると、
ブラウザでlocalhost:8080が開かれて、次のようなページが表示されます。

コンポーネントを編集してみる

このローカルサーバーはファイルに更新があったとき、
自動でブラウザの更新を行ってくれます。
それだけであればよくあるオートリロード機能なのですが、
このローカルサーバーは、
状況によって変更があった差分だけを賢く更新してくれます。
この機能（Hot Module Replacement）によって、よりスムーズに開発を進めることができます。

試しにローカルサーバーを起動した状態で
src/components/Hello.vueの<script>のmsgの文字列部分を、
次のように変更してみましょう。


Hello.vue

export default {
  name: 'hello',
  data () {
    return {
      msg: 'Welcome to CodeGrid !!'
    }
  }
}

ファイルを変更して保存すると、
Welcome to Your Vue.js Appとなっていた箇所が更新されるのを確認できます。
このとき、ローカルサーバーはブラウザをリロードすることなく、
Hello.vueというコンポーネントだけを置きかえるように更新します。

ブラウザの開発者ツールでネットワークパネルを開いた状態にしておくと、
次のような非同期通信が行われているのが確認できます。

アプリケーションの規模が大きくなると、
JavaScriptのバンドルに時間がかかるようになって無駄に時間のロスが発生しがちです。
差分更新を行うにはいろいろと設定が必要なことが多いですが、
公式のテンプレートを利用すれば一切の手間なく、効率的な開発環境が整えられます。

# .vueファイルとは

これから前回作成したアプリケーションを、
コンポーネントのコードをまとめて記述できる.vueファイルに置き換えていきますが、
置き換える前にまず、.vueファイルについて知っておきましょう。

.vueファイルを構成する3つの要素

.vueファイルは次の3つの要素で構成されています。

    <template>: コンポーネントのHTMLを記述する
    <style>: コンポーネントのCSSを記述する
    <script>: コンポーネントのJavaScriptを記述する

次のコードは.vueファイルの例です。

<template>
  <div class="my-component">
    <button @click="onClick">{{message}}</button>
  </div>
</template>

<style lang="scss" scoped>
  .my-component {
    color: tomato;
    button {
      border: 1px solid #000;
    }
  }
</style>

<script>
  export default {
    data() {
      return {
        message: 'Hello!!'
      }
    },
    methods: {
      onClick() {
        console.log(this.message)
      }
    }
  }
</script>

Vue.component()でコンポーネントを作る際には、
コンポーネントのtemplateプロパティにHTMLを文字列として記述していましたが、
.vueファイルでは分離して記述することができます。
コンポーネントのスタイルも
.vueファイルでは同一のファイル内に記述することができ、
コンポーネントのスタイルの管理が比較的やりやすくなります。
.vueファイルの<script>に記述したJavaScriptは、
vue-loaderがBabelによるトランスパイルを行うので、ES2015の構文を使用してJavaScriptを記述できます。

また、<style>では
Scoped CSSのエミュレートや、CSS ModulesによるCSSのカプセル化を行うことができます。
Sassのようなプリプロセッサも、少しの手間で利用できます。

# コンポーネントを.vueファイルにする

それでは実際に
.vueファイルへと置き換えていきましょう。前回作成したメモアプリケーションのコンポーネントは、次のようになっていました。

    前回作成したメモアプリケーションのコンポーネント

準備として、
src/componentsに次の3つのファイルを作成しておきます。

    ListItem.vue
    ListView.vue
    EditorView.vue

    ListItem.vue

    はじめにListItem.jsをListItem.vueにします。

        ListItem.js

ListItem.vueは次のようになります。
  置き換えの手順は単純で、
  コンポーネントのtemplateプロパティの値を<template>として記述し、
  それ以外のプロパティを<script>のexport default {}の中に記述します。
ListItem.vue

    <template>
      <div class="list-item">
        <div>
          <span>id</span>：
          <span>{{memo.id}}</span>
        </div>
        <div>
          <span>text</span>：
          <span>{{memo.text}}</span>
        </div>
        <div>
          <span>date</span>：
          <span>{{memo.date}}</span>
        </div>
        <div>
          <span>tags</span>：
            <span>
              <span v-for="tag in memo.tags">{{tag}}</span>
            </span>
        </div>
        <div>
          <button @click="remove(memo.id)">
            削除
          </button>
        </div>
      </div>
    </template>

    <script>
      export default{
        props: {
          memo: Object
        },
        methods: {
          remove(id) {
            this.$emit('remove', id)
          }
        }
      }
    </script>

    ListView.vue

同じようにListView.jsをListView.vueにします。

        ListView.js

ListView.vueは次のようになります。
ListViewではListItemコンポーネントを利用するので、
ES2015のimport構文を使ってListItem.vueをインポートして定義しておきます。
そしてcomponentsプロパティに指定します。

    ListView.vue

    <template>
      <div class="list-view">
        <div v-if="hasMemo">
          <list-item
            v-for="memo in memos"
            :memo="memo"
            @remove="remove">
          </list-item>
        </div>

        <div v-else>
          表示できるメモがありません。
        </div>
      </div>
    </template>

    <script>
      import ListItem from './ListItem'
      export default{
        props: {
          memos: Array
        },
        computed: {
          hasMemo() {
            return this.memos && this.memos.length !== 0
          }
        },
        methods: {
          remove(id) {
            this.$emit('remove', id)
          }
        },
        components: {
          'list-item': ListItem
        }
      }
    </script>

EditorView.vue

EditorView.jsをEditorView.vueに置き換えます。

        EditorView.js

EditorView.vueは次のようになります。書き換え方法は、これまでの.vueファイルと同様です。

EditorView.vue

    <template>
      <div class="editor-view">
        <div>
          <label>内容：</label>
          <input v-model="input.text" placeholder="メモのタイトル">
        </div>
        <div>
          <label>日付：</label>
          <input type="date" v-model="input.date">
        </div>
        <div>
          <label>タグ：</label>
          <input v-model="input.tags" placeholder="空白区切りで指定">
        </div>
        <div>
          <button @click="save">保存</button>
        </div>
      </div>
    </template>

    <script>
      export default{
        data() {
          return {
            input: {
              text: '',
              date: '',
              tags: ''
            }
          }
        },
        computed: {
          tagsArr() {
            // input.tags の文字列を空白で区切って配列に変換する
            return this.input.tags.trim() !== '' ? this.input.tags.trim().split(/\s+/) : []
          }
        },
        methods: {
          save() {
            // this.input のクローンを生成する
            const data = Object.assign({}, this.input, {tags: this.tagsArr})
            // 'add'イベントを自身にトリガーする
            this.$emit('add', data)
          }
        }
      }
    </script>

    App.vue

最後にapp.jsをApp.vueに移して、アプリケーションが動作するようにします。

        app.js

App.vueは次のようになります。
AppではListViewとEditorViewの2つのコンポーネントを利用するので、
インポートして、componentsに指定します。

App.vue

    <template>
      <div id="app">
        <editor-view @add="add"></editor-view>
        <list-view :memos="memos" @remove="remove"></list-view>
      </div>
    </template>

    <script>
      import EditorView from './components/EditorView'
      import ListView from './components/ListView'

      export default {
        name: 'app',
        data() {
          return {
            memos: [
              {
                id: 1,
                text: 'テスト',
                date: '16-10-28',
                tags: ['タグ1', 'タグ2']
              },
              {
                id: 2,
                text: 'テスト2',
                date: '16-11-28',
                tags: ['タグ2', 'タグ3']
              }
            ]
          }
        },
        computed: {
          nextId() {
            return this.memos.reduce((id, memo) => {
                return id < memo.id ? memo.id : id
              }, 0) + 1
          }
        },
        methods: {
          add(newMemo) {
            newMemo.id = this.nextId
            this.memos.push(newMemo)
          },
          remove(id) {
            const index = this.memos.findIndex((memo) => {
              return memo.id === id
            })
            this.memos.splice(index, 1)
          }
        },
        components: {
          'editor-view': EditorView,
          'list-view': ListView
        }
      }
    </script>

# アプリケーションの動作を確認する

これで前回作成したアプリケーションを
.vueファイルに置き換えることができました。
npm run devコマンドを実行し、
ローカルサーバーで確認してみましょう。
スタイルはあたっていないですが、アプリケーションは前回と同様に動作するのが確認できます。

# スタイルを読み込む

次にアプリケーションにスタイルをあててみましょう。
前回使ったstyles.cssを適用します。

静的なファイルはstaticディレクトリに格納します。
staticディレクトリにstyles.cssを格納すれば、
index.htmlから次のように参照できます。

index.htmlからスタイルを参照

<head>
  <meta charset="utf-8">
  <title>vue-memo</title>
  <link rel="stylesheet" href="/static/styles.css">
</head>

これでもいいですが、
せっかくなのでコンポーネントから参照してみましょう。
App.vueに次のように<style>を追加して参照します。

App.vueからスタイルを参照

<style>
  @import '../static/styles.css';
</style>

これでstyles.cssのスタイルが適用されて、次のような表示になります。

ここまでの状態のソースコードは、次のリポジトリに保存されていますので、
参考にしてください。

今回はvue-cliでテンプレートを利用してプロジェクトを作成し、
.vueファイルでコンポーネントを置き換えるところまでを解説しました。
vue-cliを使えば、すばやくVue.jsを使った開発の環境を整えることができるので、
積極的に利用してみてください。

次回はvue-routerを使った、ページのルーティングについて解説します。

前回はvue-cliを使ってプロジェクトを作成し、
シンプルなメモアプリケーションのコンポーネントを.jsファイルから
.vueファイルに置き換えました。
今回はvue-routerでルーティングを追加していきます。

# ページごとのファイルの作成

vue-routerでは、
ルーティングとコンポーネントをマッピングすることで、
ページに表示するコンテンツを決定します。
たとえば/にアクセスしたときには
Root.vueを表示するといった設定を記述します。

まずはルーティングにマッピングするためのコンポーネントを作成します。

ここで作成するコンポーネントに
各ページのメインコンテンツを制御する役割を持たせます。
今回は次の3つのルーティングに対して、
3つのコンポーネントを作成します。

マッピングするコンポーネントは
通常のコンポーネントと区別するためにsrc/pageディレクトリに作成します。

    /：src/page/Root.vue
    /add：src/page/Add.vue
    /items：src/page/Items.vue

この段階ではこれらのファイルの中身は空の状態で大丈夫です。

# vue-routerのインストール

次のコマンドを実行してvue-routerをインストールします。

$ npm install --save vue-router

インストールしたvue-routerはmain.jsから使いますが、
まずはルーティングの設定ファイルを先に作成します。

# ルーティング設定ファイルの作成

ルーティングの設定を記述していくファイルとして、
src/routes.jsを作成します。

ルーティングは次のように、
routesに各ルーティングの設定を
配列で記述していきます。

pathにはURLを、
componentにはマッピングするコンポーネントを指定します。
ルートにはnameで名前を付けることが可能で、名前を付けておくとページからページへのリンクが簡単になります。

routes.js

import Root from './page/Root'
import Add from './page/Add'
import Items from './page/Items'

export default {
  routes: [
    {
      path: '/', component: Root, name: 'root'
    },
    {
      path: '/add', component: Add, name: 'add'
    },
    {
      path: '/items', component: Items, name: 'items'
    }
  ]
}

動作モードを指定する

URLや履歴の操作に関して、
vue-routerには次の3つの動作モードが用意されています。

    hash
    history
    abstract

デフォルトのモードはhashで、
これは/#/items/5のように#（ハッシュ）を使ったURL Hashによるルーティングを行います。
historyモードはHTML5のHistory APIを使ったもので、
これは#のない/items/5のようなきれいなURLとなり、
完全な履歴を提供します。
abstractモードはhashにもhistoryにも対応していない環境用のモードで、
URLは一切変わらず、履歴も作られません。

どのモードを使うかはフロントエンドだけでなく、
サーバーサイドの環境が関わってくるので、サーバーサイドに合わせて適切なモードを指定しましょう。

本シリーズではhistoryモードを指定して、
アプリケーションの作成を進めていきます。指定は、次のようにrouters.jsにmodeで行います。


routes.js

...
export default {
  // modeを追記
  mode: 'history',
  routes: [
    ...
  ]
}

# ルーターインスタンスの作成と指定

src/routes.jsを元にルーティングを行うよう、
src/main.jsを次のように変更します。

Vue.use()はVue.jsでプラグインを使用するためのメソッドで、
ここではvue-routerを指定しています。
new VueRouter()でルーターインスタンスを作成し、
作成したインスタンスをVueのインスタンス作成時にrouterに指定します。
これでVue.jsがvue-routerを使ったルーティングを行ってくれるようになります。

main.js

import Vue from 'vue'
import App from './App'
import VueRouter from 'vue-router'
import routes from './routes'

Vue.use(VueRouter) // VueRouterを使うことをVueに知らせる

const router = new VueRouter(routes) // ルーターインスタンスの作成

new Vue({
  el: '#app',
  template: '<App/>',
  components: { App },
  router // router にルーターインスタンスを指定
})

このルーターインスタンスは、
各コンポーネントの
$routerプロパティとして参照できるようになります。

$routerはナビゲーションを行うためのAPIを持っているので、
コンポーネントからJavaScriptによるナビゲーションを行うことができます。

プログラムによるナビゲーションについては、ドキュメントを参照してください。

# router-viewでコンポーネントを表示する

vue-routerをインストールすると、
<router-view>と<router-link>という、
ルーティングを行うための特別な要素が使えるようになります。

src/routers.jsにルーティングとコンポーネントをマッピングする設定を記述しましたが、

このマッピングしたコンポーネントを表示するのに<router-view>を使います。

<router-link>については後述します。

src/App.vueの<template>を次のように変更します。

App.vue

<template>
  <div id="app">
    <!-- router-viewに書き換える -->
    <router-view></router-view>
  </div>
</template>

router-viewには、
設定したルーティングにマッチした場合に
マッピングしたコンポーネントが表示されることになります。

# 各ページへのナビゲーションを行うコンポーネントを作成する

各ページへのナビゲーションを行うためのNavLinkコンポーネントを作成しましょう。
src/components/NavLink.vueとして保存します。

router-linkは
vue-routerでルーティングされるページへのリンクを張るための要素です。
router-linkにはリンク先のパスをそのままto="/items"と指定することもできますが、
:to="{name: 'root-name'}"と名前を付けたルートのnameを指定するほうが、
相対パスなどを気にする必要がなくなるので、便利でわかりやすくなります。

NavLink.vue

<template>
  <nav>
    <router-link :to="{name: 'root'}">最新</router-link>
    <router-link :to="{name: 'items'}">一覧</router-link>
    <router-link :to="{name: 'add'}">追加</router-link>
  </nav>
</template>

NavLinkをApp.vueで表示するように変更します。

App.vue

...
<template>
  <div id="app">
    <!-- nav-linkを追加 -->
    <nav-link></nav-link>
    <router-view></router-view>
  </div>
</template>

<script>
// NavLinkのimport文に書き換え
import NavLink from './components/NavLink'
export default {
  ...
  components: {
    // NavLinkのみに書き換え
    NavLink
  }
}
</script>

これでリンクをクリックすることで
各ページにアクセスできるようになりました。
ただ、この段階では各ページ（.vueファイル）が空のままなので、
何も表示されません。

ページのテンプレートを変更する

ルーティングが正しく動作しているか確認するために、
各ページのコンポーネントのテンプレートを次のように変更します。

Root.vue

<template>
  <div>
    ルートページです。
  </div>
</template>

Items.vue

<template>
  <div>
    一覧ページです。
  </div>
</template>

Add.vue

<template>
  <div>
    追加ページです。
  </div>
</template>

ルーティングに設定したURLにアクセスすると、
URLの変更に合わせてマッピングしたコンポーネントが表示されるのが確認できます。

# 各ページにコンポーネントを表示する

各ページにコンポーネントを配置して、
一覧表示と、メモの追加・削除が行えるようにしましょう。

一覧ページ

まずはItems.vueで
ListViewを使ってメモの表示が行えるようにします。

Items.vueを次のように変更します。


Items.vue

<template>
  <div>
    <list-view :memos="memos" @remove="remove"></list-view>
  </div>
</template>

<script>
  import ListView from '../components/ListView'
  export default{
    props: {
      memos: Array
    },
    methods: {
      remove(id) {
        this.$emit('remove', id)
      }
    },
    components: {
      ListView
    }
  }
</script>

Items.vueは自身のデータとしてmemosを持っていないので
、propsでmemosを受け取る必要があります
。App.vueからmemosを渡すように<template>を変更します。

App.vue

<template>
  <div id="app">
    <nav-link></nav-link>
    <router-view :memos="memos" @add="add" @remove="remove"></router-view>
  </div>
</template>

ここでは
メモの追加と削除の処理が行えるように、
'add'イベントと'remove'イベントのイベントハンドラも追加しています。

# 追加ページ

次にAdd.vueでEditorViewを使ってメモの追加が行えるように、
Add.vueを次のように変更します。
ここでは$router.push()を利用して、
メモの追加処理のあとに/itemsへナビゲーションするようにします。

Add.vue

<template>
  <div>
    <editor-view @add="add"></editor-view>
  </div>
</template>

<script>
  import EditorView from '../components/EditorView'
  export default{
    methods: {
      add(data) {
        this.$emit('add', data)
        this.$router.push({name: 'items'}) //追加処理のあとに`/items`にナビゲーションする
      }
    },
    components: {
      EditorView
    }
  }
</script>

/addにアクセスして、
追加ボタンをクリックすると、/itemsへと遷移して、
追加したメモが表示されているのが確認できます。

# トップページに最新n件のメモを表示する

トップページでは、
新しく追加した順に、指定した件数だけメモが表示されるようにします。
Vue 1.x系にはビルトインのフィルタがあったので簡単にできましたが、
Vue 2.x系ではフィルタが用意されていないので、
自身でフィルタの処理を実装する必要があります。

ListViewにフィルタを実装する

まずはListViewに表示件数の指定と、表示順が指定できるようにしましょう。

ListView.vueで、
次のようにpropsでcountとsortを受け取るようにします。
そしてフィルタした結果を返すfilteredMemos
をcomputedに定義して、
表示するデータをmemosからfilteredMemosに変更します。

ListView.vue

<template>
  ...
      <!-- v-forをmemo in filteredMemosに変更  -->
      <list-item
        v-for="memo in filteredMemos"
        :memo="memo"
        @remove="remove">
      </list-item>
  ...
</template>

<script lang="babel">
  import ListItem from './ListItem'
  export default{
    props: {
      memos: Array, // 書き換え
      count: Number, // 追加
      sort: String // 追加
    },
    computed: {
      hasMemo() {
        return this.filteredMemos && this.filteredMemos.length !== 0 // memosをfilteredMemosに書き換え
      },
      // filteredMemos()の処理を追加
      filteredMemos() {
        let memos = this.memos.concat()
        if (this.sort) {
          switch(this.sort) {
            case 'latest':
              memos.reverse()
          }
        }
        if (this.count) {
          memos = memos.splice(0, this.count)
        }
        return memos
      }
    },
    ...
  }
</script>

sortがlatestの場合にデータを逆順に表示できるようになり、
countで件数が指定できるようになりました。
なにも指定がない場合には処理を行わずにそのまま表示されます。

# Root.vueを変更する

Root.vueは次のように、
ListViewに対してcount: 3と、sort: "latest"を指定します。

リストの後ろには/itemsへのリンクを追加します。

Root.vue

<template>
  <div>
    <list-view :memos="memos" @remove="remove" :count="count" :sort="sort"></list-view>
    <router-link :to="{name: 'items'}">すべて見る</router-link>
  </div>
</template>

<script>
  import ListView from '../components/ListView'
  export default{
    data() {
      return {
        count: 3,
        sort: 'latest'
      }
    },
    props: {
      memos: Array
    },
    methods: {
      remove(id) {
        this.$emit('remove', id)
      }
    },
    components: {
      ListView
    }
  }
</script>

/にアクセスすると、次のように新しい順に指定した件数だけメモが表示されます。

# ナビゲーションにスタイルを追加する

NavLinkを左サイドに表示するようにスタイルを記述していきます。

.vueファイルでSassを使えるようにする

スタイルの変更の前に、
スタイルの記述を楽にするために、.vueファイルでSassを使えるようにしておきます。

必要なのはnode-sassとsass-loaderの2つのパッケージです。
次のコマンドで2つのパッケージをインストールします。

$ npm install --save-dev node-sass sass-loader

必要なのはパッケージのインストールだけで、
設定は特に必要ありません。

スタイルを追加する

NavLink.vueを次のように変更します。
<style>の中でSass（ここではSCSS記法）が使えるように、
langにscssを指定します。

NavLink.vue

<style scoped lang="scss">
  .menu {
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    background-color: #555;
    color: #fff;
    a {
      color: inherit;
      text-decoration: none;
      display: inline-block;
      padding: 10px;
      font-weight: normal;
      font-size: 14px;
      &:link {
        color: inherit;
      }
    }
    a.router-link-active {
      background-color: #fcfcfc;
      color: #555;
    }
  }
</style>

<template>
  <nav class="menu">
    <router-link :to="{name: 'root'}">最新</router-link>
    <router-link :to="{name: 'items'}">一覧</router-link>
    <router-link :to="{name: 'add'}">追加</router-link>
  </nav>
</template>

vue-routerはrouter-linkに設定されているルーティングが、現在のURLとマッチする要素にrouter-link-activeというクラスを付与します。
このクラスにスタイルを設定することで、
現在地がどこかを示すことができます。

ただしこの判定は、
URLの先頭からの部分一致なので、/はすべてのルートにマッチしていると判定されてしまいます。
URLが完全一致したときだけクラスが適用されるように、router-link要素にexact属性を追加します。

...
<router-link :to="{name: 'root'}" exact>最新</router-link>
...

# App.vueにスタイルを追加する

ナビゲーションが左サイドに固定されるように、
App.vueを次のように変更します。router-viewにはcontentsクラスを指定します。

App.vue

<style lang="scss">
  @import '../static/styles.css';
  html, body {
    color: #555;
    margin: 0;
    padding: 0;
    height: 100vh;
  }
  #app {
    height: 100%;
    display: flex;
    .contents {
      height: 100%;
      flex-grow: 1;
      overflow: scroll;
      box-sizing: border-box;
    }
  }
</style>
<template>
  <div id="app">
    <nav-link></nav-link>
    <router-view class="contents" :memos="memos" @add="add" @remove="remove" :count="3"></router-view>
  </div>
</template>
...

これで左サイドに固定ナビゲーションが表示されるようになり、よりアプリケーションらしくなりました。

今回はvue-routerを使ったルーティングについて解説しました。

次回は、メモの編集が行えるページを、/itemsのサブルートとして作成していきます。
