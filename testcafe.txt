
TestCafeは、
E2Eでブラウザテストを自動化するためのフレームワークです。

# TestCafeの特徴

TestCafeは最初のコミットが2015年の4月、
最初のリリースが2016年10月と比較的新しいE2Eテストフレームワークといえます。

そのため、
async/awaitの使用を前提にAPIが設計されていたり、
importするモジュールがなるべく最小限になるような工夫がされていたりと、
ほかのE2Eテストフレームワークと比較すると、
モダンなJavaScriptでテストが非常に書きやすい作りになっています。

また、
自動待機のメカニズムによって、
ページ読み込みとXHRの完了だけでなく、
DOM要素の表示も待機するように作られているため、
待機するための専用APIを呼び出す必要がありません。

Webアプリケーション用のE2Eテストフレームワークと聞くと、
真っ先に思い浮かぶのはSeleniumではないでしょうか？
E2Eテストフレームワークの中でも有名なNightwatch
やProtractorを含め、
多くのE2Eテストフレームワーク
がSelenium（WebDriver）と連携して動作します。

TestCafeはそれらフレームワークと一線を画すもので、
Seleniumをまったく使用しないE2Eテストフレームワークです。
Seleniumを使用するフレームワークと比較すると、次のような特徴があります。

# テスト環境の構築が容易

TestCafeはテスト環境を容易に構築することができます。
SeleniumではWebDriverのクライアントとテストを実行する各ブラウザのWebDriverをインストールする必要があります。
一方、TestCafeであればnpmを通じてTestCafeをインストールすれば、
それだけでテスト環境が整ったことになります。設定ファイルも必要ありません。

また、TestCafeの開発者の1人であるIvan Nikulin氏によると、
Seleniumで使用されるWebDriverは各ブラウザベンダーによって開発されており、
それが互換性の問題を引き起こすことを、Seleniumを使用しない理由の1つとして挙げています。

# インストールされていない環境でもテストが実行可能

TestCafeだけでなくNode.jsすらインストールされていない環境であっても、
テストを実行することが可能です。
その場合、TestCafeが出力するURLを対象の環境のブラウザで開くだけでテストが開始されます。
これはモバイル端末にも当てはまります。
ただし、TestCafeがインストールされているホストと対象とするデバイスが、
同一ネットワーク上に存在する必要があります。

# テストコードはJavaScriptのみ

SeleniumはJavaScript以外にもJava、Ruby、Python、C#でもテストを書くことが可能ですが、
TestCafeはJavaScriptでしかテストを書くことができません。

クロスブラウザのテストサービスについて

BrowserStack、Sauce LabsといったWeb上でクロスブラウザのテストを行うサービスのために
TestCafeからプラグインが提供されています。

    testcafe-browser-provider-browserstack
    testcafe-browser-provider-saucelabs

ただし、それでもこれらサービスを利用する際には注意が必要です。
これらサービスが提供するSeleniumへのサポートが必要なケースでは、
TestCafeは適さないかもしれません。
たとえば、BrowserStackにはE2Eテストの動画を自動的に撮影する機能に加え、
各アクション（ページ遷移、クリックなど）時のスクリーンショットをキャプチャする機能がありますが、
2017年9月現在これはSeleniumにしかサポートされていません。

# TestCafeのインストール

TestCafeを理解するには、
実際にインストールしてテストを書いて体験してみるのがよいでしょう。
前述したようにTestCafeの環境構築は非常に簡単です。
インストールは、次のコマンドを実行するだけです。
問題なくインストールされれば、それだけでTestCafeのテスト環境が整ったことになります。

npm install -g testcafe

次のコマンドでバージョン確認をして、
バージョン番号が表示されれば、正常にインストールされています。

testcafe -v
0.17.1

# テストの実行

それでは、
実際にテストを書いて実行してみましょう。
デモ用の簡単なアンケートフォームを用意したので、このフォームをテストするためのコードを用意します。

このアンケートフォームには次の機能が実装されています。

    名前が必須項目であり、
    入力しないと送信ボタンを押しても送信されず、エラーメッセージが表示される。
    アンケートの送信前にブラウザの確認ダイアログが表示され、
    キャンセル選択すると送信されず、OKを押すと送信される。
    送信後、サンクスページに遷移して「（入力された名前）様、
    アンケートにお答えいただき、ありがとうございました。」というメッセージが表示される。

これらの動作のうち、「名前を入力して送信すると、
名前が入力されたサンクスページが表示される」という動作を確認してみたいと思います。

アンケートフォームをテストするためのtest.jsという名前のファイルを作成して、
次のコードを貼り付けてください。

import {Selector} from 'testcafe';

fixture('アンケートフォーム')
  .page('https://cdn.codegrid.net/2017-testcafe/demo/1.html');

test('必要項目を入力後、送信して遷移先を確認', async t => {
  const userName   = await Selector('#user-name');
  const submitButton = await Selector('#submit-button');
  await t
    .setNativeDialogHandler(() => true)
    .typeText(userName, 'ピクセルグリオ')
    .click(submitButton);
  await t.expect(Selector('#thanks-message').innerText).eql('ピクセルグリオ様、アンケートにお答えいただき、ありがとうございました。');
});

コードの文法などは、
次回詳しく解説します。ここではtest.jsに書かれていることをざっと説明します。

    アンケートフォームのページを開く
    ユーザー名の入力欄とフォーム送信ボタンの要素の参照を取得
    確認ダイアログで「OK」を選択するようにあらかじめ設定する
    ユーザー名の入力欄に"ピクセルグリオ"と入力する
    フォーム送信ボタンをクリックする
    サンクスページに期待されるメッセージが表示されているか確認する

ファイルを作成したら、
そのファイルと同じディレクトリ内で
コンソールから次のコマンドを実行してください。
このコマンドは、
TestCafeにChromeとSafariのブラウザでtest.jsのテストの実行するように指示しています。

    testcafe chrome,safari ./test.js

    自動的にブラウザが立ち上がり、テストが実行されます。

その結果がコンソール上に表示されるはずです。

  % testcafe chrome,safari ./test.js
    Running tests in:
    - Chrome 59.0.3071 / Mac OS X 10.12.6
    - Safari 10.1.2 / Mac OS X 10.12.6

    アンケートフォーム
    ✓ 必要項目を入力後、送信して遷移先を確認

     1 passed (3s)

それぞれのローカルで、
使用可能なブラウザの種類は、コマンドに-b（または、--list-browsers）オプションを
付けて実行することで確認することができます。

     % testcafe -b
     chrome
     safari
     firefox

E2Eテストは
ブラウザ用のドライバのインストールによる環境設定や
待機用のカスタムコードの記述など、
実際に実行を成功させるまでのハードルが高い傾向にありますが、
TestCafeであれば導入から実行まで、比較的スムーズに作業を進めることができたのではないでしょうか。

これに加えてE2Eのテストに関するすべてのことが
JavaScript（Node.js）で完結することも大きなメリット

これまでブラウザ上でE2Eテストを実施する場合、
Seleniumが必須というケースがほとんどだったと思いますが、
筆者はTestCafeの登場によって選択肢が1つ増えたと捉えています。

# テスト構成について

アンケートのテストを例に、
TestCafeのAPIの構成とコードについて確認してみましょう。

# fixtureとtest

TestCafeによるコードの大まかな構成は下記のようになります。
基本的には、
下記のようにまず始めに
fixtureの処理が1つだけ書かれ、
その後に続いて
testの処理が並ぶ構成になるはずです。

テストコードの基本構造

// import文
// 変数・定数等の宣言

fixture('テスト内容の分類やページのタイトル等')
  .page('テストするページのURL');

test('テスト項目1', async t => {
  //...
});
test('テスト項目2', async t => {
  //...
});
test('テスト項目3', async t => {
  //...
});

fixture関数

fixture関数によって、
テストを分類します。
1つのテストファイルに少なくとも1つのfixtureを含める必要があります。
この関数が返すオブジェクトを使用して、
通常はここでテストの開始ページを指定します。
.page()の引数にテストの開始ページのURLを渡します。

ほかにも、
そのページで初期化・クリーンアップが必要であれば、
この箇所でそれを行います。

test関数

実際にテストするコードをこのtest関数に渡します。
このメソッドの第二引数として渡される
関数 async t => {...}については、この後詳しく説明します。

テストコードを渡す

test('必要項目を入力後、送信して遷移先を確認', async t => {
  //テストコード
});

// 別のテスト
test('必要項目が未入力の場合、エラーメッセージが表示される', async t => {
  //テストコード
});

Selector

Selectorはその名のとおり、
テストに必要な要素をWebページ上から取得するためのものです。
importしたSelectorコンストラクタを使用して、
通常は次の例のようにCSSセレクタ文字列を指定することで
テストに必要な要素を特定します。

要素の特定

const userName   = await Selector('#user-name');
const submitForm = await Selector('#submit-form');

また、TestCafeが提供するAPIをメソッドチェーンでつなげて
目的の要素を絞り込んでいくことが可能です。

たとえば、
次の例ではfieldset要素内で、
テキスト内容がフロントエンドエンジニアであるlableの子要素inputを取得します。

メソッドチェーンで要素を特定

Selector('fieldset').find('label').withText('フロントエンドエンジニア').child('input');

これらのメソッドにはマッチしている要素集合を絞り込む
フィルターメソッドと、
DOM階層から要素を見つけ出すメソッドの2種類が存在します。

フィルター

nth

現在の集合から、指定されたインデックス番号の要素が選択される。
インデックス番号は０始まりで、マイナス値を指定すれば、末尾からのカウントとなる。

withText

指定された文字列をテキストとして持つ要素を選択する。
大文字・小文字は区別される。

DOM階層から検索

find

現在の要素の集合から、指定されたCSSセレクタにマッチするすべての子孫要素を選択する。

child

すべての子要素を選択する。
CSSされくたやインデックス番号などの選択条件を指定することができる。

選択した要素が存在するのか、
また選択した集合がいくつあるのかをテストしたいケースもあるでしょう。
そのために、下記のプロパティが用意されています。

要素の存在や件数の確認

exists
マッチする要素が１つでも存在すれば、trueを返す。

count
マッチしている要素の件数を返す

# テストコントローラー

tは
「テストコントローラー」と呼ばれるもので、
値の入力やクリックといったアクション、
alertなどのネイティブダイアログの操作、
そして期待したとおりの動作をしているか検証するための
アサーションといったメソッドを提供します。
これらを利用して、テストコードを構築します。

test('必要項目を入力後、送信して遷移先を確認', async t => {
  //...
  await t
    // ネイティブダイアログの操作
    .setNativeDialogHandler(() => true)
    // アクション
    .typeText(userName, 'ピクセルグリオ')
    .click(submitForm)
    // アサーション
    .expect(Selector('#thanks-message').innerText).eql('...');
});

# ネイティブダイアログの操作

setNativeDialogHandlerによって、
alertやbeforeunloadのダイアログを閉じたり、
promptで任意の文字列を指定するなど
ブラウザののネイティブダイアログを操作します。

ここでは、trueを返す関数を渡しているだけですが、
これはconfirmダイアログの場合に、
「OK」を選択することを示しています。
また関数が返す値に関係なく、alertは「OK」を選択し、
beforeunloadは「このページを離れる」を選択します。
「とどまる」をエミュレートすることはできません。

comfirmとpromptについて、
条件によって処理を分けたい場合には、
関数には次の引数が渡されるので、
この引数を使って制御します。

setNativeDialogHandler((type, text, url) => {})

type
ダイアログのタイプが、
'alert'、'confirm'、'beforeunload'、'prompt' のいずれかの文字列で渡される。

text
ダイアログのメッセージが渡される

url
ダイアログが実行されたページのURLが渡される。
ダイアログがメインウィンドウ、iframeのどちらかれあ呼び出されたかを判定する場合に使用する。

# アクション

ユーザーが操作する入力欄へのテキスト入力や、
ボタンのクリックといったアクションを、
次のようなテストコントローラーから提供されるメソッドを使用して操作します。

click 	要素のクリック
typeText 	テキスト入力
pressKey 	キーボードのキー入力
hover 	要素へのホバー
drag、dragToElement 	要素のドラッグ

# アサーション

...
  await t.expect(Selector('#thanks-message').innerText)
    .eql('ピクセルグリオ様、アンケートにお答えいただき、ありがとうございました。', 'メッセージが表示されること');
...

アサーションには次のようなメソッドが提供されます。

eql 	値が等しいことを判定する。Deep Equalによる比較が行われるため、{ a : [ 1, 2 ], b : [ 3 ] }といったオブジェクトも参照が異なっていても、まったく同じ構造と値であれば等しいと判定される。
notEql 	値が等しくないことを判定する。eql同様にDeep Equalによる比較が行われる。
ok 	対象がtrueであるかを検証する。
notOk 	検証がfalseであるかを検証する。
contains 	指定した値が含まれているかを検証する。文字列と配列で検証することが可能。

ほかにも値の大小の比較の検証や、
特定の範囲内であるかの検証のためのアサーションが用意されています。
このほかのアサーションについては、公式のAssertion methodsを参照してください。

スマートアクションクエリメカニズム

同期的なアクションであれば、
アクションの直後にアサーションを実行しても問題ありませんが、
非同期な処理が含まれるとこれが問題になります。

たとえば、
サーバーにリクエストしてそのレスポンスを受けて値を取得して適用するようなケースや、
アニメーションの完了を待って最終的な状態に達するようなケースです。
こういったケースでは、アクションの直後にアサーションが実行されてしまうと、
ネットワークの状況やテストする環境のパフォーマンスにテスト結果が左右されることになりかねません。
