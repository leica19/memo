
TestCafeは、
E2Eでブラウザテストを自動化するためのフレームワークです。

# TestCafeの特徴

TestCafeは最初のコミットが2015年の4月、
最初のリリースが2016年10月と比較的新しいE2Eテストフレームワークといえます。

そのため、
async/awaitの使用を前提にAPIが設計されていたり、
importするモジュールがなるべく最小限になるような工夫がされていたりと、
ほかのE2Eテストフレームワークと比較すると、
モダンなJavaScriptでテストが非常に書きやすい作りになっています。

また、
自動待機のメカニズムによって、
ページ読み込みとXHRの完了だけでなく、
DOM要素の表示も待機するように作られているため、
待機するための専用APIを呼び出す必要がありません。

Webアプリケーション用のE2Eテストフレームワークと聞くと、
真っ先に思い浮かぶのはSeleniumではないでしょうか？
E2Eテストフレームワークの中でも有名なNightwatch
やProtractorを含め、
多くのE2Eテストフレームワーク
がSelenium（WebDriver）と連携して動作します。

TestCafeはそれらフレームワークと一線を画すもので、
Seleniumをまったく使用しないE2Eテストフレームワークです。
Seleniumを使用するフレームワークと比較すると、次のような特徴があります。

# テスト環境の構築が容易

TestCafeはテスト環境を容易に構築することができます。
SeleniumではWebDriverのクライアントとテストを実行する各ブラウザのWebDriverをインストールする必要があります。
一方、TestCafeであればnpmを通じてTestCafeをインストールすれば、
それだけでテスト環境が整ったことになります。設定ファイルも必要ありません。

また、TestCafeの開発者の1人であるIvan Nikulin氏によると、
Seleniumで使用されるWebDriverは各ブラウザベンダーによって開発されており、
それが互換性の問題を引き起こすことを、Seleniumを使用しない理由の1つとして挙げています。

# インストールされていない環境でもテストが実行可能

TestCafeだけでなくNode.jsすらインストールされていない環境であっても、
テストを実行することが可能です。
その場合、TestCafeが出力するURLを対象の環境のブラウザで開くだけでテストが開始されます。
これはモバイル端末にも当てはまります。
ただし、TestCafeがインストールされているホストと対象とするデバイスが、
同一ネットワーク上に存在する必要があります。

# テストコードはJavaScriptのみ

SeleniumはJavaScript以外にもJava、Ruby、Python、C#でもテストを書くことが可能ですが、
TestCafeはJavaScriptでしかテストを書くことができません。

クロスブラウザのテストサービスについて

BrowserStack、Sauce LabsといったWeb上でクロスブラウザのテストを行うサービスのために
TestCafeからプラグインが提供されています。

    testcafe-browser-provider-browserstack
    testcafe-browser-provider-saucelabs

ただし、それでもこれらサービスを利用する際には注意が必要です。
これらサービスが提供するSeleniumへのサポートが必要なケースでは、
TestCafeは適さないかもしれません。
たとえば、BrowserStackにはE2Eテストの動画を自動的に撮影する機能に加え、
各アクション（ページ遷移、クリックなど）時のスクリーンショットをキャプチャする機能がありますが、
2017年9月現在これはSeleniumにしかサポートされていません。

# TestCafeのインストール

TestCafeを理解するには、
実際にインストールしてテストを書いて体験してみるのがよいでしょう。
前述したようにTestCafeの環境構築は非常に簡単です。
インストールは、次のコマンドを実行するだけです。
問題なくインストールされれば、それだけでTestCafeのテスト環境が整ったことになります。

npm install -g testcafe

次のコマンドでバージョン確認をして、
バージョン番号が表示されれば、正常にインストールされています。

testcafe -v
0.17.1

# テストの実行

それでは、
実際にテストを書いて実行してみましょう。
デモ用の簡単なアンケートフォームを用意したので、このフォームをテストするためのコードを用意します。

このアンケートフォームには次の機能が実装されています。

    名前が必須項目であり、
    入力しないと送信ボタンを押しても送信されず、エラーメッセージが表示される。
    アンケートの送信前にブラウザの確認ダイアログが表示され、
    キャンセル選択すると送信されず、OKを押すと送信される。
    送信後、サンクスページに遷移して「（入力された名前）様、
    アンケートにお答えいただき、ありがとうございました。」というメッセージが表示される。

これらの動作のうち、「名前を入力して送信すると、
名前が入力されたサンクスページが表示される」という動作を確認してみたいと思います。

アンケートフォームをテストするためのtest.jsという名前のファイルを作成して、
次のコードを貼り付けてください。

import {Selector} from 'testcafe';

fixture('アンケートフォーム')
  .page('https://cdn.codegrid.net/2017-testcafe/demo/1.html');

test('必要項目を入力後、送信して遷移先を確認', async t => {
  const userName   = await Selector('#user-name');
  const submitButton = await Selector('#submit-button');
  await t
    .setNativeDialogHandler(() => true)
    .typeText(userName, 'ピクセルグリオ')
    .click(submitButton);
  await t.expect(Selector('#thanks-message').innerText).eql('ピクセルグリオ様、アンケートにお答えいただき、ありがとうございました。');
});

コードの文法などは、
次回詳しく解説します。ここではtest.jsに書かれていることをざっと説明します。

    アンケートフォームのページを開く
    ユーザー名の入力欄とフォーム送信ボタンの要素の参照を取得
    確認ダイアログで「OK」を選択するようにあらかじめ設定する
    ユーザー名の入力欄に"ピクセルグリオ"と入力する
    フォーム送信ボタンをクリックする
    サンクスページに期待されるメッセージが表示されているか確認する

ファイルを作成したら、
そのファイルと同じディレクトリ内で
コンソールから次のコマンドを実行してください。
このコマンドは、
TestCafeにChromeとSafariのブラウザでtest.jsのテストの実行するように指示しています。

    testcafe chrome,safari ./test.js

    自動的にブラウザが立ち上がり、テストが実行されます。

その結果がコンソール上に表示されるはずです。

  % testcafe chrome,safari ./test.js
    Running tests in:
    - Chrome 59.0.3071 / Mac OS X 10.12.6
    - Safari 10.1.2 / Mac OS X 10.12.6

    アンケートフォーム
    ✓ 必要項目を入力後、送信して遷移先を確認

     1 passed (3s)

それぞれのローカルで、
使用可能なブラウザの種類は、コマンドに-b（または、--list-browsers）オプションを
付けて実行することで確認することができます。

     % testcafe -b
     chrome
     safari
     firefox

E2Eテストは
ブラウザ用のドライバのインストールによる環境設定や
待機用のカスタムコードの記述など、
実際に実行を成功させるまでのハードルが高い傾向にありますが、
TestCafeであれば導入から実行まで、比較的スムーズに作業を進めることができたのではないでしょうか。

これに加えてE2Eのテストに関するすべてのことが
JavaScript（Node.js）で完結することも大きなメリット

これまでブラウザ上でE2Eテストを実施する場合、
Seleniumが必須というケースがほとんどだったと思いますが、
筆者はTestCafeの登場によって選択肢が1つ増えたと捉えています。

# テスト構成について

アンケートのテストを例に、
TestCafeのAPIの構成とコードについて確認してみましょう。

# fixtureとtest

TestCafeによるコードの大まかな構成は下記のようになります。
基本的には、
下記のようにまず始めに
fixtureの処理が1つだけ書かれ、
その後に続いて
testの処理が並ぶ構成になるはずです。

テストコードの基本構造

// import文
// 変数・定数等の宣言

fixture('テスト内容の分類やページのタイトル等')
  .page('テストするページのURL');

test('テスト項目1', async t => {
  //...
});
test('テスト項目2', async t => {
  //...
});
test('テスト項目3', async t => {
  //...
});

fixture関数

fixture関数によって、
テストを分類します。
1つのテストファイルに少なくとも1つのfixtureを含める必要があります。
この関数が返すオブジェクトを使用して、
通常はここでテストの開始ページを指定します。
.page()の引数にテストの開始ページのURLを渡します。

ほかにも、
そのページで初期化・クリーンアップが必要であれば、
この箇所でそれを行います。

test関数

実際にテストするコードをこのtest関数に渡します。
このメソッドの第二引数として渡される
関数 async t => {...}については、この後詳しく説明します。

テストコードを渡す

test('必要項目を入力後、送信して遷移先を確認', async t => {
  //テストコード
});

// 別のテスト
test('必要項目が未入力の場合、エラーメッセージが表示される', async t => {
  //テストコード
});
