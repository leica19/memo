
RxJsとは、リアクティブ・プログラミングという考え方のもとに構築されているライブラリ

いつ起こるかわからない処理の扱いを、一貫性を持って書くことができる。

***********

端的にいうと、JSのイベントのハンドリングや非同期処理をラップし、扱いやすくするためのライブラリ

もともと2009年にマイクロソフト社によってC＃用に開発されたRx.NETというライブラリのJavaScript向けの移植で、
他にもRxの名を冠するライブラリがさまざまな言語向けに移植されています。
そのため、RxJSを学ぶと他の言語向けのRx利用者とも同じ土俵で会話ができるという、おもしろい背景がある。

「いつ起こるかわからない処理」について、我々はどのようなコードを書いてきたのか

JSでは、往々にしてイベントをハンドリングしなければならない場面がでできます。クリックされたときの処理、
スクロールしたら値を変更、ウィンドウのリサイズに応じて位置を調整、など。
これらのイベントは、ユーザーがいつその操作をするかわかりません。つまり、いつ起こるかわからない処理といえます。

いつ起こるかわからない処理に対して、JSにおいては、関数を引数に指定することで、そのときの処理内容を記述します。

この引数に指定しているのは、Func Objで、俗にコールバック、リスナー、ハンドラーなどの名前で呼ばれているものです。

ex:

window.addEventListener('scroll', () => {
  console.log(window.pageYOffset)
})

簡単な処理であれば、まだ処理の全容を把握することができます。
しかし、ここにひとたび何十行もの手続きが書かれてしまうと、その処理は追いにくいものとなってしまいます。

たとえば、通常のクリック、Altキーを押しながらのクリック、シフトキーを押しながらのクリックに応じて、
それぞれ処理を分けて書きたいとしましょう。

const buttonEl = document.querySelector('#click-me')

buttonEl.addEventListener('click', ev => {
  const spanE1 = document.createElement('span')
  if (ev.altKey) {
    spanE1.innerText = 'altKey'
  } else if (ev.shiftKey) {
    spanE1.innerText = 'shiftKey'
  } else {
    spanE1.innerText = 'clicked'
  }
  resultEl.appendChild(spanE1)
})

このように、リスナー関数の引数evを扱い、プロパティaltKey, shiftKeyの状態をif文内で検証し分岐する例です。

このようにソースコードの上から処理を下記、途中で分岐したり繰り返したりするプログラミング手法を手続き型と呼びます。

手続き型では、求める動作そのものが構造化されておらず、上から順に書かれることが起こりやすいです。
その結果、長い行数のコードは読みにくく、変更しにくいものとなっていきます。

コードが長くなったとき、しばしば処理を別の関数に分割するリファクタリングを行うことがあります。
ただ、分割をしたり、そもそも長い処理を書かないように気をつけるかどうかは、指針がなければ、人それぞれとなってしまいます。

昨今のWebアプリケーションではクリック、スクロール、ドラッグ、ドロップ、どの操作をとっても高度な処理を求められることが増えました。
そのため、保守しやすい開発を心がけようとすると、
イベントハンドリングの処理は、肥大化に注意しながら組みたてていくことが求められるようになります。

非同期通信処理

JSは、シングルスレッドで動作する言語ですが、それゆえに非同期処理を多用する文化となりました。
XHRを使ったHTTP通信では、onreadystatechangeにイベントハンドラーを登録することで、
通信中に続きの処理をブロックせずに先に進めて、通信完了の状態を受け取ったときにハンドラーに登録した処理を実行することができます。
このHTTP通信をラップして、より使いやすくしたものがQueryの$.ajax()でした。

のちに、JSは言語レベルでPromiseが実装されるようになりました。
Promiseは現代JSに置ける非同期を扱う形式として、もはやおなじみになり、XHRに続くHTTP通信用のAPIとして策定されたfetchも
このPromiseを返すようになります。

ただ、単一のPromiseは、通信状態を表しているオブジェクトではなく、あくまでも「戻ってくることが約束された値」です。
何らかの待ちが発生する処理：HTTP通信に対して、そこから戻ってくる値を表しているにすぎず、
複数の通信結果を組み合わせた処理を書く場合に、Promiseでは煩雑になりがちです。

例えば、複数のAPIの結果を使わなければならない場面を考えてみましょう。
AというAPIのレスポンスに含まれる値を、BというAPIのリクエストボディに含まなければならない。
Promiseのthen()の中で再度、別のAPIを呼び、またthen()を書くということになり、
読みづらくなります。

fetch('some/api/a'
  .then(res => {
    const id = res.id
    fetch('some/api/b', { method: 'POST', body: {id} })
      .then(res => {
        // BのAPIの完了処理
      })
  })

Promiseのthen()コールバックでは、この関数の戻り値としてPromiseを返すこともできます。
そして、Promiseを返した時、then()を続けて書くことができます。

fetch('some/api/a'
  .then(res => {
    const id = res.id
    return fetch('some/api/b', { method: 'POST', body: {id} })
    })
    .then(res => {
      // BのAPIの完了処理
    })
    
  少しシンプルになりました。
  
  ただし、このアプローチでは求めた結果は得られたとしても、
  まだ問題が残ります。
  この例では、複数のPromiseを合わせただけで、コードの書き方にも幅が生まれています。書き方に幅があるということは、
  指針を決めない限りチームで開発する上で、さまざまな書き方ができてしまう可能性があるということです。
  これではアプリケーションを通しての一貫性が失われてしまいがちです。

複数人のエンジニアで開発していくとき、アプリケーションの規模が大きくなるにつれて、
徐々に一貫性のズレは保守しにくいものとなります。これは、コードを読む際の引っ掛かりにも繋がっていきます。

JavaScript開発において、頻繁に対応しなければならない「いつ起こるかわからない処理」は、処理を関数オブジェクトとしてまとまった単位で書かなければならない性質上、人によって書き方がぶれてしまうことがありえます。if文で分岐が繰り返される長大な処理、複数のAPIを呼ぶための.then()チェーンの連なり。こんな処理を何か一貫性を持って捌けないでしょうか？
それを達成できるライブラリがRxJSです。

リアクティブプログラミング

ライブラリの名前にもあるRxとは、略称で、省略しなければReactive Extensionsという言葉になります。
では、ここにでてくる「リアクティブ」とはどういう意味でしょうか。

あるひとつのプログラミングの考え方を表す言葉として「プログラミングパラダイム」というものがあります。たとえば「オブジェクト指向プログラミング」はパラダイムのひとつで、他にもさまざまなパラダイムがあります。

その中のひとつ「リアクティブプログラミング」というパラダイムが、今回紹介するものです。リアクティブプログラミングはしばしばRPとも書かれます。

RPとは、時間と共に変化する値に対する操作を宣言的に記述していくプログラミング・パラダイムです。

時間と共に変化する値とは、たとえばタイマー、マウスカーソルやスクロールの位置、HTTP経由で送られてくるデータなどです。

つまり、これまでに説明した「いつ起こるかわからない処理」の全般をさします。

そして、これら時間とともに変化する値のひとまとまりを、
ストリーム（stream）と呼んで扱います。

https://app.codegrid.net/entry/2017-rxjs-1
