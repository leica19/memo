
RxJsとは、リアクティブ・プログラミングという考え方のもとに構築されているライブラリ

いつ起こるかわからない処理の扱いを、一貫性を持って書くことができる。

***********

端的にいうと、JSのイベントのハンドリングや非同期処理をラップし、扱いやすくするためのライブラリ

もともと2009年にマイクロソフト社によってC＃用に開発されたRx.NETというライブラリのJavaScript向けの移植で、
他にもRxの名を冠するライブラリがさまざまな言語向けに移植されています。
そのため、RxJSを学ぶと他の言語向けのRx利用者とも同じ土俵で会話ができるという、おもしろい背景がある。

「いつ起こるかわからない処理」について、我々はどのようなコードを書いてきたのか

JSでは、往々にしてイベントをハンドリングしなければならない場面がでできます。クリックされたときの処理、
スクロールしたら値を変更、ウィンドウのリサイズに応じて位置を調整、など。
これらのイベントは、ユーザーがいつその操作をするかわかりません。つまり、いつ起こるかわからない処理といえます。

いつ起こるかわからない処理に対して、JSにおいては、関数を引数に指定することで、そのときの処理内容を記述します。

この引数に指定しているのは、Func Objで、俗にコールバック、リスナー、ハンドラーなどの名前で呼ばれているものです。

ex:

window.addEventListener('scroll', () => {
  console.log(window.pageYOffset)
})

簡単な処理であれば、まだ処理の全容を把握することができます。
しかし、ここにひとたび何十行もの手続きが書かれてしまうと、その処理は追いにくいものとなってしまいます。

たとえば、通常のクリック、Altキーを押しながらのクリック、シフトキーを押しながらのクリックに応じて、
それぞれ処理を分けて書きたいとしましょう。

const buttonEl = document.querySelector('#click-me')

buttonEl.addEventListener('click', ev => {
  const spanE1 = document.createElement('span')
  if (ev.altKey) {
    spanE1.innerText = 'altKey'
  } else if (ev.shiftKey) {
    spanE1.innerText = 'shiftKey'
  } else {
    spanE1.innerText = 'clicked'
  }
  resultEl.appendChild(spanE1)
})

このように、リスナー関数の引数evを扱い、プロパティaltKey, shiftKeyの状態をif文内で検証し分岐する例です。

このようにソースコードの上から処理を下記、途中で分岐したり繰り返したりするプログラミング手法を手続き型と呼びます。

手続き型では、求める動作そのものが構造化されておらず、上から順に書かれることが起こりやすいです。
その結果、長い行数のコードは読みにくく、変更しにくいものとなっていきます。

コードが長くなったとき、しばしば処理を別の関数に分割するリファクタリングを行うことがあります。
ただ、分割をしたり、そもそも長い処理を書かないように気をつけるかどうかは、指針がなければ、人それぞれとなってしまいます。

昨今のWebアプリケーションではクリック、スクロール、ドラッグ、ドロップ、どの操作をとっても高度な処理を求められることが増えました。
そのため、保守しやすい開発を心がけようとすると、
イベントハンドリングの処理は、肥大化に注意しながら組みたてていくことが求められるようになります。

非同期通信処理

JSは、シングルスレッドで動作する言語ですが、それゆえに非同期処理を多用する文化となりました。
XHRを使ったHTTP通信では、onreadystatechangeにイベントハンドラーを登録することで、
通信中に続きの処理をブロックせずに先に進めて、通信完了の状態を受け取ったときにハンドラーに登録した処理を実行することができます。
このHTTP通信をラップして、より使いやすくしたものがQueryの$.ajax()でした。

https://app.codegrid.net/entry/2017-rxjs-1
